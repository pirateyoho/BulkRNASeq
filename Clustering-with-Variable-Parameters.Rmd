---
title: "Unsupervised-hierarchical-clustering"
author: "Eileen Owens"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
```

```{r load-packages, include=FALSE}
# Load R software packages
library(BiocManager)
library(DESeq2)
library(clusterProfiler)
library(corrplot)
library(RColorBrewer)
library(pheatmap)
library(dplyr)
library(readr)
library(knitr)
library(ggplot2)
library(cowplot)
library(gridExtra)
library(rtracklayer)
library(Rsamtools)
library(grid)
library(GGally)
# library(edgeR)
library(stringr)
library(matrixStats)
library(gridExtra)
library(magrittr)
library(GSVA)
library(dplyr)
library(GSEABase)
library(shinyjs)
library(shinybusy)
library(qusage)
library(msigdbr)
library(Biobase)
library(dendextend)
library(factoextra)
library(NbClust)
```

```{r working-directory, include=FALSE}
# Set your working directory
setwd("/Users/eileen/PTCL/PROJ02_100PTCLs/02_scripts")
```

# INTRODUCTION
This script performs clustering and heatmapping of RNA-seq data based on variable input and variable parameters for filtering genes. "Raw count data" refers to the raw tabulated reads generated by featureCounts. "Normalized counts" refers to the matrix of count data generated after raw counts were normalized by DESeq2. "Vst transformed data" refers to normalized counts generated by DESeq2 that subsequently underwent variance stabilized transformation.

# Input: Raw count data
## Import raw read counts and metadata
```{r raw-count-import, results='hide'}
# Import raw count data
rawCounts <- read.table("../01_input/ROSCFam1Alignment_feature_counts.txt", header = FALSE, row.names = 1, skip = 2) # Read in the featureCounts file. Row.names = 1 assigns the first column (Ensembl IDs) as as the rownames. Skip=2 skips the first 2 lines.
metadata <- read.table(file = "../01_input/100PTCLs_metadata.txt", header = FALSE) # Read in a metadata file with paired fasta filenames  in the first two columns, sample ID in the third column, and experiment group/phenotype in the fourth column.
colnames(metadata) <- c("fasta1", "fasta2", "sample_name", "phenotype") # Add column headers
as.vector(metadata$sample_name) # Create a vector of sample names from the metadata file to assign as column names in the rawCounts table.
colnames(rawCounts) <- c("chr", "start", "stop", "strand", "length", as.vector(metadata$sample_name)) # Assign column names to rawCounts table.
rawCounts <- rawCounts[ , -which(names(rawCounts) %in% c("chr", "start", "stop", "strand", "length"))] # Remove any columns that don't contain raw count data.
```
## Filter input data prior to clustering
Select genes with high variance and mean for clustering. Including genes with low variance in gene counts can add unwanted signal that blurs the biological variation.

```{r Figure1}
# Calculate mean and variance for each gene
z_var <- apply(rawCounts, 1, var) # Setting 1 for the margin parameter tells the function to apply it over rows.
z_mean <- apply(rawCounts, 1, mean)

# Plotting the mean versus standard deviation
plot(log2(z_mean), log2(z_var), pch='.', col="deepskyblue")
abline(h=log2(10000), col='darkgreen')
abline(v=log2(5000), col='darkgreen')
text(x=17,y=30, labels="variance > 10000 \n & \n mean > 5000", col='darkgreen')
```
Figure: Mean versus variance. The mean and variance of 31,121 genes across 96 canine PTCL, 2 canine CD4 thymocyte, and 5 canine CD4 nodal lymphocyte samples are plotted here. Input:Raw counts.

Keep the genes with variance >10000 and mean >5000
```{r filter-rawCounts}
z <- rawCounts[which(z_var > 10000 & z_mean > 5000),]
dim(z) # See how many genes are left after filtering.
```

Scale the data.
```{r scale-rawCounts}
scaledata <- t(scale(t(z))) # Scale the data to normalize the dataset usijng the mean and standard deviation.
scaledata <- scaledata[complete.cases(scaledata),] # Return a logical vector indicating which cases are complete; i.e., have no missing values.
```

### Determine the optimal number of hierarchical clusters

Elbow method: Finds the "elbow" point, where the dataset becomes flat or linear after applying the cluster analysis algorithm. I.e., it is the point where adding additional data samples does not change cluster membership much. After this point, you start seeing diminishing returns by increasing the number of clusters.
```{r eblow-rawCounts}
# Elbow method
fviz_nbclust(scaledata, hcut, method="wss") +
  geom_vline(xintercept = 4, linetype =2) +
  labs(subtitle="Elbow method. Input: Raw counts")
```
Figure: The optimal number of hierarchical clusters for this data set based on the elbow method. Input: Raw counts.

Silhouette method: Determines whether there are large gaps between each sample and all other samples within the same cluster or across different clusters. Measures how close a point lies to its nearest neighbor, across all clusters.
```{r silhouette-rawCounts}
# Silhouette method
fviz_nbclust(scaledata, hcut, method="silhouette")+
  labs(subtitle="Silhouette method. Input: Raw counts")
```
Figure: The optimal number of hierarchical clusters for this data set based on the silhouette method. Input: Raw counts.

## Hierarchical clustering
```{r metadata-rawCounts, include=FALSE}
samplePhenotype <- metadata[,3:4] # Reduce metadata to just the columns of sample name and phenotype.
rownames(samplePhenotype) <- samplePhenotype$sample_name # Make sample names the rownames
samplePhenotype <- samplePhenotype[,2,drop=FALSE] # Drop the sample name column
```

Heatmap: hierarchical clustering, euclidean distance
```{r Figure5, fig.width=10, fig.height=6}
# Draw the heatmap
ph <- pheatmap(scaledata, 
               cutree_cols = 4, 
               show_rownames = F,
               clustering_method = "ward.D2",
               annotation_col = samplePhenotype,
               main="Input:Raw count, Ward clustering, Euclidean distance")
ph
```
Figure: Heatmap of 4,105 genes with variance >10,000 and mean >5,000. Clustering method: Ward. Distance method: Euclidean. Input: Raw count.

Getting the dendrogram from hierarchical clustering using Ward method and euclidean distance.
```{r Table1}
hc = hclust((dist(t(scaledata), method="euclidean")), method = "ward.D2")
lbl <- cutree(hc, 4) # Split gene dendrogram into 4 groups
knitr::kable(data.frame(table(lbl)), caption = "Table 1: Number of samples in each of 4 hierarchical clusters based on raw count, ward clustering, euclidean distance")
```

Dendrogram: hierarchical clustering, euclidean distance
```{r Figure6, fig.width=10, fig.height=6}
TreeC <- as.dendrogram(hc, method="ward.D2")
plot(TreeC,
     main="Input: Raw counts, Ward clustering, \n euclidean distance",
     ylab="Height")
colored_bars(lbl,TreeC, sort_by_labels_order = T, y_scale=5, y_shift=0.1, rowLabels=c("k=4"), cex.rowLabels=0.7)
```
Figure: Dendrogram of 103 samples hierarchically clustered using Ward clustering method and euclidean distance method. Input:Raw counts.


Heatmap: hierarchical clustering, spearman correlation distance
```{r hclust-Spearman-rawCounts}
# Clustering of samples using spearman correlation distance method and ward.D2 clustering
hr <- hclust(as.dist(1-cor(t(scaledata), method="pearson")), method="ward.D2") # Cluster rows by Pearson method
hc <- hclust(as.dist(1-cor(scaledata, method="spearman")), method="ward.D2") # Cluster columns by Spearman method
```

```{r Figure7, fig.width=8, fig.height=6}
ph <- pheatmap(scaledata, 
               cutree_cols=4,
               cluster_rows=hr,
               cluster_cols=hc,
               show_rownames=F,
               annotation_col = samplePhenotype,
               main="Input:Raw count, Ward clustering, Spearman correlation distance"
               )
ph
```
Figure: Heatmap of genes with variance >10,000 and mean >5,000. Clustering method: Ward. Distance method: Spearman correlation. Input: Raw counts.


Getting the dendrogram from hierarchical clustering Ward.d2 and spearman correlation distance.
```{r Table2}
lbl <- cutree(hc, 4) # split gene dendrogram into 4 groups
knitr::kable(data.frame(table(lbl)), caption="Table 2: Number of samples in each of 4 hierarchical clusters based on spearman correlation distance. Input:Raw counts.")
```

Dendrogram: hierarchical clustering, spearman correlation distance
```{r Figure8, fig.width=10, fig.height=6}
TreeC <- as.dendrogram(hc, method="ward.D2")
plot(TreeC,
     main="Input:Raw counts \n using Ward clustering, \n Spearman correlation distance",
     ylab="Height")
colored_bars(lbl, TreeC, sort_by_labels_order=T, y_scale=0.1, y_shift=0.01, rowLabels=c("k=4"), cex.rowlabels=0.7)
```
Figure: Dendrogram of 103 samples hierarchically clustered using Ward method and spearman correlation distance method. Input: Raw counts.

## Kmean clustering
### Determine the optimal number of k-mean clusters

Elbow method: Finds the "elbow" point, where the dataset becomes flat or linear after applying the cluster analysis algorithm. I.e., it is the point where adding additional data samples does not change cluster membership much. After this point, you start seeing diminishing returns by increasing the number of clusters.
```{r eblow-kmean-rawCounts}
# Elbow method
fviz_nbclust(scaledata, kmeans, method="wss") +
  geom_vline(xintercept = 4, linetype =2) +
  labs(subtitle="Elbow method. Input: Raw counts")
```
Figure: The optimal number of k-means clusters for this data set based on the elbow method. Input: Raw counts.

Silhouette method: Determines whether there are large gaps between each sample and all other samples within the same cluster or across different clusters. Measures how close a point lies to its nearest neighbor, across all clusters.
```{r silhouette-kmean-rawCounts}
# Silhouette method
fviz_nbclust(scaledata, kmeans, method="silhouette")+
  labs(subtitle="Silhouette method. Input: Raw counts")
```
Figure: The optimal number of k-means clusters for this data set based on the silhouette method. Input: Raw counts.

```{r Table3}
# Kmean clustering with 4 groups
set.seed(1)
kmean.01 <- kmeans(t(scaledata), centers=4, nstart=20, iter.max=1000, trace=FALSE)
knitr::kable(table(kmean.01$cluster), caption="Table 3: Number of samples in each of Kmean clusters. Input: Raw counts.")
```
```{r kmean-withinss-rawcounts}
kmean.01$withinss # Vector of within-cluster sum of squares, one component per cluster
```

Heatmap
```{r Figure12}
ph <- pheatmap(t(kmean.01$centers),
               show_rownames=F,
               cluster_cols=F,
               scale="row",
               main="Heatmap of centroids of K-mean cluster samples. Input: Raw Counts")
ph
```
Figure: Heatmap of centroids of 4 K-mean cluster samples. The sample clusters were based on 4,105 genes with variance >10,000 and mean >5,000. Input: Raw counts.


###Cluster Plot
```{r Figure13, fig.width=6, fig.height=4}
fviz_cluster(kmean.01, data = t(scaledata),
             palette = c("#2E9FDF", "purple", "gold3", "red"),
             ellipse = TRUE,
             ellipse.type = "convex",
             ggtheme = theme_bw(),
             show.cluster.cent = TRUE,
             labelsize = 7,
             repel = TRUE,
             main = "Input: Raw counts, K-means cluster plot")
```
Figure: Samples within 4 K-mean clusters. Input: Raw counts.


# Input: DESeq2 Normalized Counts 
## Import DESeq2 normalized count data.
```{r dataimport-normalizedCounts}
exdata <- read.csv("../03_output/ROS CFam 1.0/NormalizedCounts_ROSCFam1.csv") # read in the csv of normalized counts
rownames(exdata) <- exdata$probe_id # Make Ensembl gene IDs the rownames.
exdata <- dplyr::select(exdata, -c("X", "probe_id", "gene_name", "description")) # remove any columns that do not contain normalized counts for the samples
```

## Filter input data prior to clustering
Select genes with high variance and mean for clustering.
```{r Figure14}
# Calculate mean and variance for each gene
z_var <- apply(exdata, 1, var)
z_mean <- apply(exdata, 1, mean)

plot(z_mean, z_var, pch='.', col="deepskyblue")
abline(h=10000, col='darkgreen')
abline(v=5000, col='darkgreen')
text(x=11, y=25, labels="variance > 5 \n & \n mean >2", col='darkgreen')
```
Figure: Mean versus variance. The mean and variance of 25,728 genes across 96 canine PTCL, 2 canine CD4 thymocyte, and 5 canine CD4 nodal lymphocyte samples are plotted here. Input: DESeq2 normalized counts.

Keep the genes with variance >5 and mean >2
```{r filtering-normalizedCounts}
z <- exdata[which(z_var > 5 & z_mean > 2),]
dim(z) # See how many genes are left after filtering.
```

Scale the data.
```{r scaledata-normalizedCounts}
scaledata <- t(scale(t(z)))
scaledata <- scaledata[complete.cases(scaledata),] # Returns a logical vector indicating which cases are complete; i.e., have no missing values.
```

## Hierarchical clustering 
### Determine the optimal number of hierarchical clusters

Elbow method: Finds the "elbow" point, where the dataset becomes flat or linear after applying the cluster analysis algorithm. I.e., it is the point where adding additional data samples does not change cluster membership much. After this point, you start seeing diminishing returns by increasing the number of clusters.
```{r eblow-normCounts}
# Elbow method
fviz_nbclust(scaledata, hcut, method="wss") +
  geom_vline(xintercept = 4, linetype =2) +
  labs(subtitle="Elbow method. Input: DESeq2 normalized counts")
```
Figure: The optimal number of hierarchical clusters for this data set based on the elbow method. Input: DESeq2 normalized counts.

Silhouette method: Determines whether there are large gaps between each sample and all other samples within the same cluster or across different clusters. Measures how close a point lies to its nearest neighbor, across all clusters.
```{r silhouette-normCounts}
# Silhouette method
fviz_nbclust(scaledata, hcut, method="silhouette")+
  labs(subtitle="Silhouette method. Input: DESeq2 normalized Counts")
```
Figure: The optimal number of hierarchical clusters for this data set based on the silhouette method. Input: DESeq2 normalized counts.

###Heatmap: Hierarchical clusering, euclidean distance
```{r Figure18, fig.width=8, fig.height=6}
ph <- pheatmap(scaledata, 
               cutree_cols=4, 
               show_rownames=F, 
               clustering_method="ward.D2",
               main="Input: DESeq2 normalized counts, Ward clustering, euclidean distance")
ph
```
Figure: Heatmap of genes with both variance >5 and mean >2. Clustering method: Ward. Distance method: Euclidean. Input: DESeq2 normalized counts.

Get the dendrogram from hierarchical clustering using Ward method and euclidean distance.
```{r cuttree-normCounts}
hc = hclust((dist(t(scaledata), method="euclidean")), method = "ward.D2")
lbl <- cutree(hc, 4) # split gene dendrogram in 4 groups
knitr::kable(data.frame(table(lbl)), caption="Table 4: Number of samples in each of 4 hierarchical clusetrs based on euclidean disrtance. Input: DESeq2 normalized counts.")
```

###Dendrogram: hierarchical clustering, euclidean distance
```{r Figure19, fig.width=10, fig.height=6}
TreeC <- as.dendrogram(hc, method="ward.D2")
plot(TreeC,
     main="Input: DESeq2 normalized counts, Ward clustering, \n euclidean distance",
     ylab = "Height")
colored_bars(lbl, TreeC, sort_by_labels_order=T, y_shift = 2, rowLabels = c("k=4"), cex.rowLabels = 0.7)
```
Figure: Dendrogram of 103 samples hierarchically clustered using Ward clustering method and euclidean distance method. Input: DESeq2 normalized counts.

Clustering of samples using spearman correlation distance method and Ward clustering
```{r hclustSpearman-normCounts}
hr <- hclust(as.dist(1-cor(t(scaledata), method="pearson")), method="ward.D2") # Cluster rows by pearson
hc <- hclust(as.dist(1-cor(scaledata, method="spearman")), method="ward.D2") # Cluster columns by spearman correlation
```

###Heatmap: hierarchical clustering, spearman correlation distance
```{r Figure20, fig.width=8, fig.height=6}
ph <- pheatmap(scaledata, 
               cuttree_cols=4,
               cluster_rows=hr,
               cluster_cols=hc,
               show_rownames=F,
               main="Input: DESeq2 normalized counts, Ward clustering, Spearman correlation distance")
ph
```
Figure: Heatmap of genes with variance >5 and mean >2. Clustering method: Ward. Distance method: Spearman correlation. Input: DESeq2 normalized counts.

Get dendrogram from hierarchical clustering by Ward and Spearman correlation distance.
```{r cutreeSpearman-normCounts}
lbl <- cutree(hc, 4) # split gene dendrogram into 4 groups
knitr::kable(data.frame(table(lbl)), caption="Table 5: Number of samples ni each of 4 hierarchical clusters based on Spearman correlation distance. Input: DESeq2 normalized counts.")
```

###Dendrogram: Hierarchical clustering, spearman correlation distance
```{r Figure21, fig.width=10, fig.height=6}
TreeC <- as.dendrogram(hc, method="ward.D2")
plot(TreeC,
     main="Input: DESeq2 normalized counts \n using Ward clustering, \n Spearman correlation distance",
     ylab="Height")
colored_bars(lbl, TreeC, sort_by_labels_order=T, y_shift=0.02, rowLabs=c("k=4"), cex.rowLabels = 0.7)
```
Figure: Dendrogram of 103 samples hierarchically clustered using Ward method and spearman correlation distance method. Input: DESeq2 normalized counts.

## Kmean clustering
### Determine the optimal number of k-means clusters

Elbow method: Finds the "elbow" point, where the dataset becomes flat or linear after applying the cluster analysis algorithm. I.e., it is the point where adding additional data samples does not change cluster membership much. After this point, you start seeing diminishing returns by increasing the number of clusters.
```{r eblow-kmeans-normCounts}
# Elbow method
fviz_nbclust(scaledata, hcut, method="wss") +
  geom_vline(xintercept = 4, linetype =2) +
  labs(subtitle="Elbow method. Input: DESeq2 normalized counts")
```
Figure: The optimal number of k-means clusters for this data set based on the elbow method. Input: Deseq2 normalized counts.

Silhouette method: Determines whether there are large gaps between each sample and all other samples within the same cluster or across different clusters. Measures how close a point lies to its nearest neighbor, across all clusters.
```{r silhouette-kmeans-normCounts}
# Silhouette method
fviz_nbclust(scaledata, hcut, method="silhouette")+
  labs(subtitle="Silhouette method. Input: DESeq2 normalized counts")
```
Figure: The optimal number of k-means clusters for this data set based on the silhouette method. Input: DESeq2 normalized counts.

Kmean clustering with 4 groups.
```{r kmeans-normalizedCounts}
set.seed(400)
kmean.01 <- kmeans(t(scaledata), centers=4, nstart=20, iter.max=1000, trace=FALSE)
knitr::kable(table(kmean.01$cluster), caption = "Table 6: Number of samples in each of K-mean clusters. Input: DESeq2 normalized counts.")
```

```{r kmeans-withinss-normalizedCounts}
kmean.01$withinss
```

### Heatmap
```{r Figure24}
ph <- pheatmap(t(kmean.01$centers), show_rownames = F, cluster_cols = F, scale="row")
ph
```
Figure: Heatmap of centroids of 4 K-mean sample clusters. The sample clusters were based on genes with variance >5 and mean >2. Input: DESeq2 normalized counts.

### Cluster plot
```{r Figure25, fig.width=6, fig.height=4}
fviz_cluster(kmean.01, data = t(scaledata),
             palette = c("#2E9FDF", "purple", "gold3", "red"),
             geom=c("text", "point"),
             ellipse = TRUE,
             ellipse.type = "convex",
             ggtheme = theme_bw(),
             show.cluster.cent = TRUE,
             labelsize = 7,
             repel = TRUE,
             main = "Input: DESeq2 normalized counts, K-means cluster plot")
```
Figure: Samples with 4 K-mean clusters. Input: DESeq2 normalized counts.


# Input: Variance Stabilized Transformed DESeq2 Normalized Counts 
## Import vst transformed DESeq2 normalized count data.
```{r data-import-vst}
exdata <- read.csv("../03_output/ROS CFam 1.0/vst_transformedNormalizedCountData.csv") # read in the csv of normalized counts
rownames(exdata) <- exdata$X # Make Ensembl gene IDs the rownames. If they were the rownames of the imported .csv file, they will be in a column called "X". If they existed in a named column rather than as rownames, replace "X" in this line with whatever the name of the column is that contains the Ensembl probe IDs.
exdata <- dplyr::select(exdata, -c("X")) # remove any columns that do not contain normalized counts for the samples. In this case, it was only column "X". Adjust as necessary based on your spreadsheet of vst normalized counts.
```

## Filter input data prior to clustering
Select genes with high variance and mean for clustering.
```{r Figure26}
# Calculate mean and variance for each gene
z_var <- apply(exdata, 1, var)
z_mean <- apply(exdata, 1, mean)

plot(z_mean, z_var, pch='.', col="deepskyblue")
abline(h=10000, col='darkgreen')
abline(v=5000, col='darkgreen')
text(x=11, y=25, labels="variance > 5 \n & \n mean >2", col='darkgreen')
```
Figure: Mean versus variance. The mean and variance of 25,728 genes across 96 canine PTCL, 2 canine CD4 thymocyte, and 5 canine CD4 nodal lymphocyte samples are plotted here. Input: Vst transformed DESeq2 normalized counts.


Keep the genes with variance >5 and mean >2
```{r gene-filtering-vst}
z <- exdata[which(z_var > 5 & z_mean > 2),]
dim(z) # See how many genes are left after filtering.
```

Scale the data.
```{r data-scale-vst}
scaledata <- t(scale(t(z)))
scaledata <- scaledata[complete.cases(scaledata),] # Returns a logical vector indicating which cases are complete; i.e., have no missing values.
```

## Hierarchical clustering
### Determine the optimal number of hierarchical clusters

Elbow method: Finds the "elbow" point, where the dataset becomes flat or linear after applying the cluster analysis algorithm. I.e., it is the point where adding additional data samples does not change cluster membership much. After this point, you start seeing diminishing returns by increasing the number of clusters.
```{r eblow-vstCounts}
# Elbow method
fviz_nbclust(scaledata, hcut, method="wss") +
  geom_vline(xintercept = 4, linetype =2) +
  labs(subtitle="Elbow method. Input: Vst transformed DESeq2 normalized counts")
```
Figure: The optimal number of hierarchical clusters for this data set based on the elbow method. Input: Vst transformed DESeq2 normalized counts.

Silhouette method: Determines whether there are large gaps between each sample and all other samples within the same cluster or across different clusters. Measures how close a point lies to its nearest neighbor, across all clusters.
```{r silhouette-vstCounts}
# Silhouette method
fviz_nbclust(scaledata, hcut, method="silhouette")+
  labs(subtitle="Silhouette method. Input: Vst transformed DESeq2 normalized counts")
```
Figure: The optimal number of hierarchical clusters for this data set based on the silhouette method. Input: Vst transformed DESeq2 normalized counts.

### Heatmap: Hierarchical clustering, euclidean distance
```{r Figure30, fig.width=10, fig.height=6}
ph <- pheatmap(scaledata, 
               cutree_cols = 4, 
               show_rownames = F, 
               clustering_method = "ward.D2",
               main="Input: Vst transformed DESeq2 normalized counts, Ward clustering, euclidean distance")
ph
```
Figure: Heatmap of genes with variance >5 and mean >2. Clustering method: Ward. Distance method: Euclidean. Input: Vst transformed DESeq2 normalized counts.

Get the dendrogram from hierarchical clustering using Ward method and euclidean distance.
```{r cutree-hclustEuclid-vst}
hc = hclust((dist(t(scaledata), method="euclidean")), method = "ward.D2")
lbl <- cutree(hc, 4) # split gene dendrogram in 4 groups
knitr::kable(data.frame(table(lbl)), caption="Table 4: Number of samples in each of 4 hierarchical clusetrs based on euclidean distance. Input: Vst transformed DESeq2 normalized counts.")
```

###Dendrogram: hierarchical clustering, euclidean distance
```{r Figure31, fig.width=10, fig.height=6}
TreeC <- as.dendrogram(hc, method="ward.D2")
plot(TreeC,
     main="Input: Vst transformed DESeq2 normalized counts, Ward clustering, \n euclidean distance",
     ylab = "Height")
colored_bars(lbl, TreeC, sort_by_labels_order=T, y_shift = 2, rowLabels = c("k=4"), cex.rowLabels = 0.7)
```
Figure: Dendrogram of 103 samples hierarchically clustered using Ward clustering method and euclidean distance method. Input: Vst transformed DESeq2 normalized counts.

Clustering of samples using spearman correlation distance method and Ward clustering
```{r hclustSpearman-vst}
hr <- hclust(as.dist(1-cor(t(scaledata), method="pearson")), method="ward.D2") # Cluster rows by pearson
hc <- hclust(as.dist(1-cor(scaledata, method="spearman")), method="ward.D2") # Cluster columns by spearman correlation
```

###Heatmap: hierarchical clustering, spearman correlation distance
```{r Figure32, fig.width=8, fig.height=6}
ph <- pheatmap(scaledata, 
               cuttree_cols=4,
               cluster_rows=hr,
               cluster_cols=hc,
               show_rownames=F,
               main="Input: Vst transformed DESeq2 normalized counts, Ward clustering, Spearman correlation distance")
ph
```
Figure: Heatmap of genes with variance >5 and mean >2. Clustering method: Ward. Distance method: Spearman correlation. Input: Vst transformed DESeq2 normalized counts.

Get dendrogram from hierarchical clustering by Ward and Spearman correlation distance.
```{r cutreeSpearman-vst}
lbl <- cutree(hc, 4) # split gene dendrogram into 4 groups
knitr::kable(data.frame(table(lbl)), caption="Table 6: Number of samples ni each of 4 hierarchical clusters based on Spearman correlation distance. Input: Vst transformed DESeq2 normalized counts.")
```

###Dendrogram: Hierarchical clustering, spearman correlation distance
```{r Figure33, fig.width=10, fig.height=6}
TreeC <- as.dendrogram(hc, method="ward.D2")
plot(TreeC,
     main="Input: Vst transformed DESeq2 normalized counts \n using Ward clustering, \n Spearman correlation distance",
     ylab="Height")
colored_bars(lbl, TreeC, sort_by_labels_order=T, y_shift=0.05, rowLabs=c("k=4"), cex.rowLabels = 0.7)
```
Figure: Dendrogram of 103 samples hierarchically clustered using Ward method and spearman correlation distance method. Input: Vst transformed DESeq2 normalized counts.

## Kmean clustering
### Determine the optimal number of k-means clusters

Elbow method: Finds the "elbow" point, where the dataset becomes flat or linear after applying the cluster analysis algorithm. I.e., it is the point where adding additional data samples does not change cluster membership much. After this point, you start seeing diminishing returns by increasing the number of clusters.
```{r eblow-kmeans-vstCounts}
# Elbow method
fviz_nbclust(scaledata, kmeans, method="wss") +
  geom_vline(xintercept = 4, linetype =2) +
  labs(subtitle="Elbow method. Input: Vst transformed DESeq2 normalized counts")
```
Figure: The optimal number of k-means clusters for this data set based on the elbow method. Input: Vst transformed DESeq2 normalized countss.

Silhouette method: Determines whether there are large gaps between each sample and all other samples within the same cluster or across different clusters. Measures how close a point lies to its nearest neighbor, across all clusters.
```{r silhouette-kmeans-vstCounts}
# Silhouette method
fviz_nbclust(scaledata, kmeans, method="silhouette")+
  labs(subtitle="Silhouette method. Input: Vst transformed DESeq2 normalized counts")
```
Figure: The optimal number of k-means clusters for this data set based on the silhouette method. Input: Vst transformed DESeq2 normalized counts.

Kmean clustering with 4 groups.
```{r kmean-vst}
set.seed(500)
kmean.01 <- kmeans(t(scaledata), centers=4, nstart=20, iter.max=1000, trace=FALSE)
knitr::kable(table(kmean.01$cluster), caption = "Table 7: Number of samples in each of K-mean clusters. Input: Vst transformed DESeq2 normalized counts.")
```

```{r kmean-withinss-vst}
kmean.01$withinss
```

### Heatmap
```{r Figure37}
ph <- pheatmap(t(kmean.01$centers), show_rownames = F, cluster_cols = F, scale="row", main="Heatmap of centroids of K-mean cluster samples. Input: Vst transformed counts")
ph
```
Figure: Heatmap of centroids of 4 K-mean sample clusters. The sample clusters were based on genes with variance >5 and mean >2. Input: Vst transformed DESeq2 normalized counts.

### Cluster plot
```{r Figure38, fig.width=6, fig.height=4}
fviz_cluster(kmean.01, data = t(scaledata),
             palette = c("#2E9FDF", "purple", "gold3", "red"),
             geom=c("text", "point"),
             ellipse = TRUE,
             ellipse.type = "convex",
             ggtheme = theme_bw(),
             show.cluster.cent = TRUE,
             labelsize = 7,
             repel = TRUE,
             main = "Input: Vst transformed DeSeq2 normalized counts, K-means cluster plot")
```
Figure: Samples with 4 K-mean clusters. Input: Vst transformed DESeq2 normalized counts.


# Unsupervised hierarchical clustering
Unsupervised hierarchical clustering by expression of the top 2000 genes with highest median absolute derivation across all samples.

## Import dds object from DESeq2
```{r dds-object-import}
# Import dds object from DESeq2.
dds <- readRDS("../01_input/Saved_DDS_Objects/230606_DDS_100PTCLs_ROSCFam1.RData")
# Perform vst transformation
vsd <- assay(vst(dds))
# Inspect object
head(vsd)
```

## Feature selection
The median absolute derivation and standard deviation are calculated for all rows in the read count data, and the top 2000 for each are selected for unsupervised heirarchical clustering.
```{r feature-select-madstdev}
# Calculate the median absolute derivation and standard deviation for all rows in the vst transformed data. Note that the "1" in the 'apply' function indicates that the manipulation is performed on rows.
mads = apply(vsd,1,mad) # median absolute deviation
stdev = apply(vsd,1,sd) # standard deviation

# check data distribution
hist(mads, ylim=c(0,200), breaks=nrow(vsd)*0.1)
hist(stdev, breaks=nrow(vsd)*0.1)

# selecting features: top 2000 genes based on median absolute deviation or standard deviation
# This indexes the vst transformed count data to include only those rows (probe IDs) that appeared in the top 2000 based on MAD or SD.
mad2k=vsd[rev(order(mads))[1:2000],]
sd2k=vsd[rev(order(stdev))[1:2000],]

```
### Import metadata for patient phenotype
```{r metadata-uhclust, results='hide'}
# Import metadata
samplePhenotype <- read.csv("../01_input/100PTCLs_metadata_2column.csv") # metadata file with sample name in one column and phenotype in a second column.
rownames(samplePhenotype) <- colnames(mad2k) # colnames of mad2k should be the sample names.
samplePhenotype <- samplePhenotype[,2, drop=FALSE] # Since we don't want the sample names annotated, remove this column now that we have rownames assigned to the appropriate sample ID.

```
### Convert probe ID to gene symbols for annotation on heatmaps.
```{r metadata-uhclust-2}
# Import metadata for probe IDs
genenames <- read.csv('../01_input/ROSCFam1GeneDescription.csv') # First column should be probe_id and second column gene_name

# Convert count data from matrix array to data frame for easier merging of gene symbols for probe IDs
mad2k = as.data.frame(mad2k)
sd2k = as.data.frame(sd2k)

# Merge the gene symbol metadata with our count data by probe ID.
mad2k$probe_id <- rownames(mad2k) # Add probe ID column
mad2k <- merge(as(mad2k,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Adds a column of gene names for the associated probe ID

sd2k$probe_id <- rownames(sd2k) # Add probe ID column
sd2k <- merge(as(sd2k,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Adds a column of gene names for the associated probe ID

# Make the gene symbol column the rownames
genesymbols <- c(mad2k$gene_name)
rownames(mad2k) <- make.names(genesymbols, unique=TRUE) # unique=T will avoid errors if two rows have the same gene symbol

genesymbols <- c(sd2k$gene_name)
rownames(sd2k) <- make.names(genesymbols, unique=TRUE)

# Drop the probe ID, gene symbol, and description columns.
mad2k <- subset(mad2k, select = -c(probe_id, gene_name, description))
sd2k <- subset(sd2k, select = -c(probe_id, gene_name, description))

# Inspect final result. Row names should be gene symbols, column names should be patient sample IDs, and there should be 2000 rows total.
head(mad2k)
dim(mad2k)
head(sd2k)
dim(sd2k)
```


## Heatmaps
### Unsupervised hierarchical clustering of vst transformed read count data of the top 2000 genes (by median absolute derivation)
```{r mad-heatmap}
mad_heatmap <- pheatmap(mad2k, 
              scale="row", 
              color = colorRampPalette(c("blue", "white", "red"), space = "Lab")(100),
              cluster_rows=TRUE, 
              cluster_cols=TRUE, 
              clustering_distance_rows = "euclidean",
              clustering_distance_cols = "euclidean",
              clustering_method = "ward.D2",
              annotation_col = samplePhenotype,
              show_rownames = FALSE) # Change to TRUE if gene symbols should be annotated on the heatmap.
```
Figure: Heatmap of top 2000 genes with highest median absolute derivation. Clustering method: Ward. Distance method: Euclidean. Input: Vst transformed DESeq2 normalized counts.

### Unsupervised hierarchical clustering of vst transformed read count data of the top 2000 genes (by standard derivation)
```{r sd-heatmap}
sd_heatmap <- pheatmap(sd2k, 
              scale="row", 
              color = colorRampPalette(c("blue", "white", "red"), space = "Lab")(100),
              cluster_rows=TRUE, 
              cluster_cols=TRUE, 
              clustering_distance_rows = "euclidean",
              clustering_distance_cols = "euclidean",
              clustering_method = "ward.D2",
              annotation_col = samplePhenotype,
              show_rownames = FALSE) # Change to TRUE if gene symbols should be annotated on the heatmap.
```
Figure: Heatmap of top 2000 genes with highest standard derivation. Clustering method: Ward. Distance method: Euclidean. Input: Vst transformed DESeq2 normalized counts.

# Citations
```{r}
sessionInfo()
citation()
```

