---
title: "RNAseq-Analysis"
author: "Eileen Owens"
date: "`r Sys.Date()`"
output:
  html_document:
  keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 300,
                      echo = TRUE,
                      cache = TRUE,
                      warning = FALSE,
                      keep_md = TRUE)
```
# Introduction
The purpose of this script is to perform a differential gene expression analysis on RNA-seq data with DESeq2. The DESeq2 documentation is available here: https://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html

```{r instructions, results='hide', include=FALSE}
# BEORE KNITTING THIS RMARKDOWN, make sure all code chunks have the options you desire in their header:
# eval=FALSE --> this code chunk will not be run
# include=FALSE --> code chunk will be run but not displayed in the final document
# echo=FALSE --> will run the code but will not display it in the code chunk above its results in the final document
# results='hide' --> code will be run and shown in the final document, but its results will not be displayed
# message=FALSE --> code will be run and shown in the final document, but no messages generated by the code will be displayed
```


# 1. Loading data and packages

## 1.1 Install necessary software packages (first time only):
```{r installation, results="hide", eval=FALSE}
if (!require("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
BiocManager::install(version = "3.18", force=TRUE)

options(BioC_mirror = "http://bioconductor.org")

BiocManager::install("DESeq2")
BiocManager::install("apeglm")
install.packages("corrplot")
install.packages("pheatmap")
install.packages("RColorBrewer")
install.packages("rlang")
BiocManager::install("clusterProfiler")
BiocManager::install("pathview")
BiocManager::install("enrichplot")
BiocManager::install("EnhancedVolcano")
```

## 1.2 Load necessary software packages (every time):
```{r software-load, results="hide", message=FALSE}
library(DESeq2)
library(corrplot)
library(RColorBrewer)
library(pheatmap)
library(apeglm)
library(tidyverse)
library(clusterProfiler)
library(enrichplot)
```

## 1.3 Read in the featureCounts data and metadata:
```{r data-input, results="hide"}
# Set the appropriate working directory.
setwd("/Users/path/to/02_scripts") # copy the path to your 02_scripts directory and paste it here, in quotations. If you are a Windows user, you may have to swap the direction of your slashes from "\" to "/"

# Read in the FeatureCounts file.
countsData <- read.table(file = "../01_input/FeatureCountsFileName.txt", header = FALSE, row.names = 1, skip = 2) # row.names = 1 assigns the first column (geneid) as the row names for the data frame.

# Read in the metadata file in which the first column contains sample IDs and the subsequent columns contain information about those samples. 
metadata <- read.table(file = "../01_input/metadata.txt", header = FALSE)
colnames(metadata) <- c("sample_name", "phenotype") # Adds column headers; ADJUST AS APPROPRIATE FOR YOUR METADATA FILE: e.g., c("sample_name", "phenotype", "sex", "breed", "etc")

### Give column names to countsData file: ###
as.vector(metadata$sample_name) # The last column names will be names for each sample. We can pull those names from metadata.
colnames(countsData) <- c("chr", "start", "stop", "strand", "length", as.vector(metadata$sample_name))
```

## 1.4 Make count matrix (cts) file for DESeq2

If using all samples, run the following chunk. Otherwise, skip this code chunk and include "echo=FALSE, eval=FALSE, include=FALSE" in the code chunk options prior to knitting.
```{r cts, results="hide"}
colnames(countsData) # Check the column numbers that contain your samples for indexing below.
head(countsData[,6:108]) # Adjust the indexing as needed to include only the sample columns with read counts. For example, [6:108] indexes on the 6th through 108th column.

# Save just the subset as an object called cts:
cts <- as.matrix(countsData[,6:108]) 
```

If using only only a subset of samples (e.g., only including certain phenotypes), adjust as necessary and run this code chunk. Otherwise, skip this code chunk and include "echo=FALSE, eval=FALSE, include=FALSE" in the code chunk options prior to knitting.
```{r cts_subset, results="hide", echo=FALSE, eval=FALSE, include=FALSE}
# To select for only certain phenotypes, include this code. Otherwise, comment out to include all samples.
colnames(countsData)
countsData_subset <- dplyr::select(countsData, -c("chr", "start", "stop", "strand", "length", "sample-to-exclude-1", "sample-to-exclude-2")) # Removes all columns except the count data for the desired samples.

# Save just the subset as an object called cts:
cts <- as.matrix(countsData_subset)
```

## 1.5 Make coldata file for DESeq2

If running all samples, use the following code chunk. Otherwise, skip this code chunk and include "echo=FALSE, eval=FALSE, include=FALSE" in the code chunk options prior to knitting.
```{r coldata}
# Reorganize the metadata table so the sample_name column values are now row names. If your metadata file includes more information than just a phenotype column (i.e., a column for sex, age, etc.), adjust this code as necessary.
rownames(metadata)<- metadata$sample_name
coldata <- metadata[, c("phenotype", "any other headers"), drop=FALSE] # drop=FALSE keeps row names
coldata$phenotype <- as.factor(coldata$phenotype)

# Ensure that the rownames of coldata exactly match the colnames of cts:
all(rownames(coldata) == colnames(cts)) # Should return TRUE
```

If using only a subset of samples, run the following code chunk. Otherwise, skip this code chunk and include "echo=FALSE, eval=FALSE, include=FALSE" in the code chunk options prior to knitting.
```{r coldata_subset, echo=FALSE, eval=FALSE, include=FALSE}
# Subset the metadata to only include the subset of interest.
remove_list <- c("sample-to-exclude-1", "sample-to-exclude-2") # Can paste the list used when making cts above
metadata_subset <- metadata %>%
  filter(! sample_name %in% remove_list)

# Reorganize the metadata table so the sample_name column values are now row headers.
rownames(metadata_subset)<- metadata_subset$sample_name
coldata <- metadata_subset[, c("phenotype"), drop=FALSE] # drop=FALSE keeps row names
coldata$phenotype <- as.factor(coldata$phenotype)

# Ensure that the rownames of coldata exactly match the colnames of cts:
all(rownames(coldata) == colnames(cts)) # Should return TRUE
```

# 2. Running a differential expression analysis with DESeq2

## 2.1 Set parameters for the study. 
See the DESeq2 manual (https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#quick-start) for examples and to ensure you're selecting the best design for your analysis. 
```{r dds, results="hide"}
dds <- DESeqDataSetFromMatrix(countData = cts,
                              colData = coldata,
                              design = ~ phenotype)
```

## 2.2 Filter for present genes
Excludes all samples that have less than 10 reads.
```{r filter-DESeq2-output-1, results="hide"}
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
```

## 2.3 Remove any samples to be excluded from the differential expression analysis (previously determined outliers, etc.) 
```{r filter-DESeq2-output-2, results='hide'}
# Comment this section out if no samples are to be excluded from the analysis.
#colnames(dds) # See which column contains the outlier.
#dds <- dds[,-X] # Replace X with column number that contains the outlier(s).
#colnames(dds)
```

## 2.4 Optional: Set factor levels
By default, R will choose a reference level for factors based on alphabetical order. Then, if you never tell the DESeq2 functions which level you want to compare against (e.g. which level represents the control group), the comparisons will be based on the alphabetical order of the levels. There are two solutions: you can either explicitly tell results which comparison to make using the contrast argument later, or you can explicitly set the factors levels. By default, this script does not set factor levels ahead of time, and instead uses the contrast argument later. If you choose to set factor levels, un-comment the code in this chunk and modify accordingly.
```{r factor-levels, results="hide"}
## There are 2 ways to set the factor level. Run one of the following below:
#dds$condition <- factor(dds$phenotype, levels = c("CTRL","Phenotype1","Phenotype2")) # Control group is listed first.
## OR
#dds$condition <- relevel(dds$phenotype, ref = "CTRL") # Relevel requires only specifying the reference level.
```

## 2.5A Perform DESeq2 analysis
```{r DESeq2, results="hide", message=FALSE}
dds <- DESeq(dds)
```

## 2.5B Save the dds object for ease of import in any downstream analyses.
```{r RDS, eval=FALSE}
saveRDS(dds, file="../03_output/DATE_PROJECTNAME_DDS.Rdata")
```

## 2.6 Plot dispersion estimates
A simple helper function that plots the per-gene dispersion estimates together with the fitted mean-dispersion relationship. This is a good way to double check your data is a good fit for the DESeq2 model. The data should generally scatter around the curve, with dispersion increasing with increasing mean expression levels. For more info and examples of what "good" and "bad" dispersion plots look like, see https://hbctraining.github.io/DGE_workshop_salmon_online/lessons/04b_DGE_DESeq2_analysis.html. 
```{r plot-dispersion, message=FALSE, fig.height=5, fig.width=8, fig.fullwidth=TRUE}
plotDispEsts(dds)
```

## 2.7 Perform a principal component analysis to identify any outliers before proceeding.
Perform a variance stabilized transformation of the normalized count data and perform the plotPCA function.
```{r PCA, results='hide'}
# Optional: Doing an rlog transformation of normalized count data instead of vst; takes longer with >50 samples.
#rld <- rlog(dds, blind=TRUE)
#rlog_pcaData <- plotPCA(rld, intgroup = "phenotype", returnData = TRUE)

vsd <- vst(dds, blind=TRUE)
vsd_pcaData <- plotPCA(vsd, intgroup="phenotype", returnData=TRUE)
```

### 2.7.1 Export the intgroup covariates used for PCA plotting:
```{r PCA-export}
# write.csv(rlog_pcaData, file="../03_output/<date>_PCA_data_rlog.csv")
write.csv(vsd_pcaData, file="../03_output/DATE_PCA_data_vst.csv")
```

### 2.7.3 Draw the PCA plot
```{r PCA-plot, message=FALSE, fig.height=8, fig.width=6, fig.fullwidth=TRUE}
#rlog_pcaData <- plotPCA(rld, intgroup = "phenotype", returnData = FALSE) +
 # geom_text(aes(label = colnames(rld)), position = position_nudge(y = -2)) # Uses the name column of rld as the dot label.
#rlog_pcaData

vsd_pcaData <- plotPCA(vsd, intgroup="phenotype", returnData=FALSE) +
  geom_text(aes(label=colnames(vsd)), position = position_nudge(y = -2))
vsd_pcaData
```
If principal component analysis reveals any outliers, go back up to section 2.4 and execute that code.


## 2.8 Differential expression analysis
Calculate the statistically significant differences between conditions. Specify the coefficient or contrast you want to build a results table for. Save each comparison to its own variable. Follow up with log fold change shrinkage for visualization and gene ranking.

```{r DEG-instructions, eval=FALSE, include=FALSE}
# The appropriate format is as follows: 
#BvsC <- results(dds, contrast=c("condition", "B", "C"))
#AvsB <- results(dds,contrast=c("condition", "A", "B"))
```

```{r res-file-generation, results='hide', message=FALSE}
res <- results(dds)

# If you set factor levels earlier, uncomment this section; otherwise, run a different "results" function for each comparison.
# resultsNames(dds) # lists the coefficients
#resLFC <- lfcShrink(dds, coef="phenotype_CD4_PTCL_vs_CD4_CTRL", type="apeglm")
#head(resLFC)

Group1vsGroup2_results <- results(dds, contrast=c("phenotype", "Group1", "Group2")) # Replace Group1 and Group2 with phenotypes from metadata.
Group1vsGroup2_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group1", "Group2"), res=Group1vsGroup2_results, type="normal")


Group1vsGroup3_results <- results(dds, contrast=c("phenotype", "Group1", "Group3")) # Replace Group1 and Group3 with phenotypes from metadata.
Group1vsGroup3_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group1", "Group3"), res=Group1vsGroup3_results, type="normal")


Group2vsGroup1_results <- results(dds, contrast=c("phenotype", "Group2", "Group1")) # Replace Group2 and Group1 with phenotypes from metadata.
Group2vsGroup1_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group2", "Group1"), res=Group2vsGroup1_results, type="normal")


Group2vsGroup3_results <- results(dds, contrast=c("phenotype", "Group2", "Group3")) # Replace Group2 and Group3 with phenotypes from metadata.
Group2vsGroup3_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group2", "Group3"), res=Group2vsGroup3_results, type="normal")


Group3vsGroup1_results <- results(dds, contrast=c("phenotype", "Group3", "Group1")) # Replace Group3 and Group1 with phenotypes from metadata.
Group3vsGroup1_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group3", "Group1"), res=Group3vsGroup1_results, type="normal")


Group3vsGroup2_results <- results(dds, contrast=c("phenotype", "Group3", "Group2")) # Replace Group3 and Group2 with phenotypes from metadata.
Group3vsGroup2_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group3", "Group2"), res=Group3vsGroup2_results, type="normal")
```

# 3. Exporting DESeq2 Data
## 3.1 Exporting results tables
Add a column with gene names, as the results tables in their current form only have the probe ID.
```{r DESeq2-data-export, results='hide'}
# Import a csv file where the first column is labeled "probe_id" and contains the probe IDs, and the second column is labeled "gene_name" and contains the preferred gene names.
genenames <- read.csv('../01_input/gene.description.csv')

# Add a column to the results table containing the probe IDs, which are currently the rownames.
Group1vsGroup2_shrink$probe_id <- rownames(Group1vsGroup2_shrink)

# Merge the genenames metadata file with the results tables by probe ID.
Group1vsGroup2_final_res <- merge(as(Group1vsGroup2_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE) # The all.x=TRUE argument says that it should include rows of CD4PTCLvsCD4CTRL_shrink even if there is no matching row of the genenames table.

# Convert probe ID back the rownames and remove the probe ID column.
rownames(Group1vsGroup2_final_res) <- Group1vsGroup2_final_res$probe_id
Group1vsGroup2_final_res <- Group1vsGroup2_final_res[,-1]

# Export the final result as a .csv file.
write.csv(Group1vsGroup2_final_res, file="../03_output/Group1vsGroup2_DESeq2res.csv")
```

Repeat for all comparisons.
```{r DESeq2-data-export-2, results='hide'}
Group1vsGroup3_shrink$probe_id <- rownames(Group1vsGroup3_shrink)
Group1vsGroup3_final_res <- merge(as(Group1vsGroup3_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group1vsGroup3_final_res) <- Group1vsGroup3_final_res$probe_id
Group1vsGroup3_final_res <- Group1vsGroup3_final_res[,-1]
write.csv(Group1vsGroup3_final_res, file="../03_output/Group1vsGroup3_DESeq2res.csv")

Group2vsGroup1_shrink$probe_id <- rownames(Group2vsGroup1_shrink)
Group2vsGroup1_final_res <- merge(as(Group2vsGroup1_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group2vsGroup1_final_res) <- Group2vsGroup1_final_res$probe_id
Group2vsGroup1_final_res <- Group2vsGroup1_final_res[,-1]
write.csv(Group2vsGroup1_final_res, file="../03_output/Group2vsGroup1_DESeq2res.csv")

Group2vsGroup3_shrink$probe_id <- rownames(Group2vsGroup3_shrink)
Group2vsGroup3_final_res <- merge(as(Group2vsGroup3_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group2vsGroup3_final_res) <- Group2vsGroup3_final_res$probe_id
Group2vsGroup3_final_res <- Group2vsGroup3_final_res[,-1]
write.csv(Group2vsGroup3_final_res, file="../03_output/Group2vsGroup3_DESeq2res.csv")

Group3vsGroup1_shrink$probe_id <- rownames(Group3vsGroup1_shrink)
Group3vsGroup1_final_res <- merge(as(Group3vsGroup1_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group3vsGroup1_final_res) <- Group3vsGroup1_final_res$probe_id
Group3vsGroup1_final_res <- Group3vsGroup1_final_res[,-1]
write.csv(Group3vsGroup1_final_res, file="../03_output/Group3vsGroup1_DESeq2res.csv")

Group3vsGroup2_shrink$probe_id <- rownames(Group3vsGroup2_shrink)
Group3vsGroup2_final_res <- merge(as(Group3vsGroup2_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group3vsGroup2_final_res) <- Group3vsGroup2_final_res$probe_id
Group3vsGroup2_final_res <- Group3vsGroup2_final_res[,-1]
write.csv(Group3vsGroup2_final_res, file="../03_output/Group3vsGroup2_DESeq2res.csv")
```

## 3.2 Exporting normalized count data
```{r export-normalized-counts, results='hide'}
sizeFactors(dds)
normalized_counts <- as.data.frame(counts(dds, normalized=TRUE))
normalized_counts$probe_id <- rownames(normalized_counts) # Add a column with probe ID.
normalized_counts <- merge(as(normalized_counts,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Add column with gene names.
write.csv(normalized_counts, file="../03_output/<date>_NormalizedCounts.csv")
```


# 4. Data Visualization

## 4.1 MA plots
Shows the log2 fold changes attributable to a given variable over the mean of normalized counts for all the samples in the DESeqDataSet.

```{r MAplot, fig.height=6, fig.width=10, fig.fullwidth=TRUE}
plotMA(Group1vsGroup2_shrink, main="Group1 vs Group2", ylim = c(-7,7), 
       ylab = "log fold change",
       xlab = "means of normalized counts")
```

## 4.2 Plot Counts
A function for examining the counts of reads for a single gene across the groups. It normalizes counts by the estimated size factors (or normalization factors if these were used) and adds a pseudocount of 1/2 to allow for log scale plotting. The counts are grouped by the variables in "intgroup", where more than one variable can be specified.
```{r PlotCounts, eval=FALSE, message=FALSE}
plotCounts(dds, gene=which(rownames(res) == "ENSCAFGXXXXXX"), intgroup="phenotype") #Replace with Ensembl ID of your gene of interest
```

## 4.3 Plot multiple genes with phenotype labels
Make the lists of genes to include in each plot. Examples using different T cell subtypes are shown here, but modify accordingly for your project.
```{r gene-lists, results='hide'}
# T cell phenotypes
CD8genes <- c("EOMES", "IFNG", "TNF", "PRF1", "GZMB", "GZMA")
Th1genes <- c("TBX21", "IFNG", "TNF")
Th2genes <- c("GATA3", "IL4R", "IL5", "IL13")
Th17genes <- c("RORC", "STAT3", "IL17A", "IL17C", "IL17F")
Treggenes <- c("FOXP3", "IL10", "TGFB1")
Tfhgenes <- c("BCL6", "IL21R", "CXCL13", "CXCR5")

# TCR signaling genes
TCRgenes <- c("CD3E", "CD3D", "CD3G", "CD28", "ZAP70", "LCK", "FYN", "IL2RA", "IL2RB", "IL2RG")

# Markers of immaturity
precursorGenes <- c("CD34", "KIT", "DNTT")
```

Subset the normalized counts matrix (the version that includes a column of gene names) for each group, then gather the columns to get the normalized counts in a single column.
```{r gene-list-subsets, results='hide', message=FALSE}
# First, see which columns contain your samples, and adjust the indexing below accordingly. For example, [2:41] indexes on the 2nd through 41st column.
colnames(normalized_counts)

CD8subset <- normalized_counts %>%
  filter(gene_name %in% CD8genes)
gathered_CD8subset <- CD8subset %>%
  gather(colnames(CD8subset)[2:41], key = "sample_name", value="normalized_counts")
gathered_CD8subset$normalized_counts <- as.numeric(as.character(gathered_CD8subset$normalized_counts)) # Ensures that the normalized count data are in the "numeric" class.
```

Repeat for all subsets.
```{r gene-list-subsets-2, results='hide', message=FALSE}
Th1subset <- normalized_counts %>%
  filter(gene_name %in% Th1genes)
Th2subset <- normalized_counts %>%
  filter(gene_name %in% Th2genes)
Th17subset <- normalized_counts %>%
  filter(gene_name %in% Th17genes)
Tregsubset <- normalized_counts %>%
  filter(gene_name %in% Treggenes)
Tfhsubset <- normalized_counts %>%
  filter(gene_name %in% Tfhgenes)
TCRsubset <- normalized_counts %>%
  filter(gene_name %in% TCRgenes)
precursorSubset <- normalized_counts %>%
  filter(gene_name %in% precursorGenes)

gathered_Th1subset <- Th1subset %>%
  gather(colnames(Th1subset)[2:41], key = "sample_name", value="normalized_counts")
gathered_Th1subset$normalized_counts <- as.numeric(as.character(gathered_Th1subset$normalized_counts))

gathered_Th2subset <- Th2subset %>%
  gather(colnames(Th2subset)[2:41], key = "sample_name", value="normalized_counts")
gathered_Th2subset$normalized_counts <- as.numeric(as.character(gathered_Th2subset$normalized_counts))

gathered_Th17subset <- Th17subset %>%
  gather(colnames(Th17subset)[2:41], key = "sample_name", value="normalized_counts")
gathered_Th17subset$normalized_counts <- as.numeric(as.character(gathered_Th17subset$normalized_counts))

gathered_Tregsubset <- Tregsubset %>%
  gather(colnames(Tregsubset)[2:41], key = "sample_name", value="normalized_counts")
gathered_Tregsubset$normalized_counts <- as.numeric(as.character(gathered_Tregsubset$normalized_counts))

gathered_Tfhsubset <- Tfhsubset %>%
  gather(colnames(Tfhsubset)[2:41], key = "sample_name", value="normalized_counts")
gathered_Tfhsubset$normalized_counts <- as.numeric(as.character(gathered_Tfhsubset$normalized_counts))

gathered_TCRsubset <- TCRsubset %>%
  gather(colnames(TCRsubset)[2:41], key = "sample_name", value="normalized_counts")
gathered_TCRsubset$normalized_counts <- as.numeric(as.character(gathered_TCRsubset$normalized_counts))

gathered_precursorSubset <- precursorSubset %>%
  gather(colnames(precursorSubset)[2:41], key = "sample_name", value="normalized_counts")
gathered_precursorSubset$normalized_counts <- as.numeric(as.character(gathered_precursorSubset$normalized_counts))

```

Combine with the metadata information to allow coloring of counts by sample group.
```{r gene-list-subsets-3, results='hide', message=FALSE}
gathered_CD8subset <- inner_join(metadata, gathered_CD8subset) # This will merge the 2 data frames with respect to the "sample_name" column (i.e., a column with the same column name in both data frames)
```

Repeat for all groups.
```{r gene-list-subsets-4, results='hide', message=FALSE}
gathered_Th1subset <- inner_join(metadata, gathered_Th1subset)
gathered_Th2subset <- inner_join(metadata, gathered_Th2subset)
gathered_Th17subset <- inner_join(metadata, gathered_Th17subset)
gathered_Tregsubset <- inner_join(metadata, gathered_Tregsubset)
gathered_Tfhsubset <- inner_join(metadata, gathered_Tfhsubset)
gathered_TCRsubset <- inner_join(metadata, gathered_TCRsubset)
gathered_precursorSubset <- inner_join(metadata, gathered_precursorSubset)
```

Plot the counts.
```{r plot-counts-gene-lists, message=FALSE}
jitter <- position_jitter(width=0.1, height=0.1)

ggplot(gathered_CD8subset, aes(x=gene_name, y=normalized_counts)) +
  geom_point(aes(color=phenotype), position=jitter) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Expression of CD8 Associated Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(size=12, face="bold", angle=45, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5))

ggplot(gathered_Th1subset, aes(x=gene_name, y=normalized_counts)) +
  geom_point(aes(color=phenotype), position=jitter) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Expression of Th1 Associated Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(size=12, face="bold", angle=45, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5))

ggplot(gathered_Th2subset, aes(x=gene_name, y=normalized_counts)) +
  geom_point(aes(color=phenotype), position=jitter) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Expression of Th2 Associated Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(size=12, face="bold", angle=45, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5))

ggplot(gathered_Th17subset, aes(x=gene_name, y=normalized_counts)) +
  geom_point(aes(color=phenotype), position=jitter) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Expression of Th17 Associated Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(size=12, face="bold", angle=45, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5))

ggplot(gathered_Tregsubset, aes(x=gene_name, y=normalized_counts)) +
  geom_point(aes(color=phenotype), position=jitter) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Expression of Treg Associated Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(size=12, face="bold", angle=45, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5))

ggplot(gathered_Tfhsubset, aes(x=gene_name, y=normalized_counts)) +
  geom_point(aes(color=phenotype), position=jitter) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Expression of Tfh Associated Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(size=12, face="bold", angle=45, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5))

ggplot(gathered_TCRsubset, aes(x=gene_name, y=normalized_counts)) +
  geom_point(aes(color=phenotype), position=jitter) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Expression of Genes Associated with TCR Signaling") +
  theme_bw() +
  theme(axis.text.x = element_text(size=12, face="bold", angle=45, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5))

ggplot(gathered_precursorSubset, aes(x=gene_name, y=normalized_counts)) +
  geom_point(aes(color=phenotype), position=jitter) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Expression of Markers of Immaturity") +
  theme_bw() +
  theme(axis.text.x = element_text(size=12, face="bold", angle=45, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5))
```

## 4.4 Optional: Plot counts for a subset of samples only.
Run the following code with the desired samples to exclude, then go back to 4.3 and replace "normalized_counts" with "normalized_counts_subset". Be sure to adjust your indexing to reflect the columns (samples) that have been excluded.
```{r plot-counts-subset, message=FALSE, eval=FALSE}
sampleSubset <- c("probe_id", "Sample1", "Sample2", "Sample3", "gene_name")
normalized_counts_subset <- normalized_counts[, sampleSubset]
```


## 4.5 Correlation Matrices
Evaluate the sample-to-sample correlation by calculating the distances (dissimilarities) between each sample and creating a matrix of distance values.
```{r corr-matrix-setup, message=FALSE}
rld <- rlog(dds, blind=TRUE)
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix(sampleDists) #convert from data.frame -> matrix
rownames(sampleDistMatrix) <- paste(rld$phenotype, colnames(rld), sep="-") # Add sample labels
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255) #Pick colors
```

Use this matrix to draw a heatmap that groups samples based on their gene expression similarity.
```{r corr-matrix, message=FALSE}
p <- pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

## 4.6 Volcano Plots
Volcano plots are a nice way of displaying the fold change against the p-value.
```{r EnhancedVolcano, message=FALSE, fig.height=4, fig.width=8.5, fig.fullwidth=TRUE}
library(EnhancedVolcano) # load the package
volcano_data1 <- Group1vsGroup2_final_res

EnhancedVolcano(volcano_data1, 
                lab = volcano_data1$gene_name,
                x = 'log2FoldChange',
                y = 'padj',
                title = 'Group1 vs. Group2',
                FCcutoff = 1.5,
                pCutoff = 0.05,
                pointSize = 2.0,
                labSize = 4.0,
                labCol = 'black',
                labFace = 'bold',
                colAlpha = 4/5,
                legendPosition = 'right',
                legendLabSize = 12,
                legendIconSize = 6.0,
                drawConnectors = TRUE,
                widthConnectors = 0.2,
                colConnectors = 'black'
                )

# Repeat for as many comparisons as desired
volcano_data2 <- Group2vsGroup1_final_res

EnhancedVolcano(volcano_data2, 
                lab = volcano_data2$gene_name,
                x = 'log2FoldChange',
                y = 'padj',
                title = 'Group1 vs. Group2',
                FCcutoff = 1.5,
                pCutoff = 0.05,
                pointSize = 2.0,
                labSize = 4.0,
                labCol = 'black',
                labFace = 'bold',
                colAlpha = 4/5,
                legendPosition = 'right',
                legendLabSize = 12,
                legendIconSize = 6.0,
                drawConnectors = TRUE,
                widthConnectors = 0.2,
                colConnectors = 'black'
                )
```

```{r EnhancedVolcano-selectGenes, message=FALSE, fig.height=4.5, fig.width=6, fig.fullwidth=TRUE}
# Volcano plot with only key variables labeled:
EnhancedVolcano(volcano_data1, 
                lab = volcano_data1$gene_name,
                x = 'log2FoldChange',
                y = 'padj',
                selectLab = c('GATA3', 'PTEN', 'IFNG', 'EOMES', 'TBX21', 'KIT', 'DNTT', 'CD34', 'IL2RA', 'IL2RB', 'DLA-DRA', 'DLA-DQA1', 'HLA-DQB1', 'HLA-DQB2'), # Replace these gene names with your genes of interest.
                title = 'Group1 vs. Group2',
                FCcutoff = 1.5,
                pCutoff = 0.05,
                pointSize = 2.0,
                labSize = 4.0,
                labCol = 'black',
                labFace = 'bold',
                colAlpha = 4/5,
                legendPosition = 'right',
                legendLabSize = 12,
                legendIconSize = 6.0,
                drawConnectors = TRUE,
                widthConnectors = 0.2,
                colConnectors = 'black'
                )
```

# 5. Final data export

## 5.1 Export the matrices of rlog and vst transformed normalized counts:
```{r}
# Perform r-stabilized log transformation of the count data and export.
rld_matrix <- assay(rlog(dds, blind=FALSE))
rld_matrix <- as.data.frame(rld_matrix, drop=FALSE) # Convert to a data frame.
rld_matrix$probe_id <- rownames(rld_matrix) # Add probe ID as a column
rld_matrix <- merge(as(rld_matrix,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Adds a column of gene names for the associated probe ID
write.csv(rld_matrix, file="../03_output/<date>_Rlog_Transformed_Matrix_of_NormalizedCounts.csv") # Export as csv

# Perform variance stabilized transformation of the count data and export.
vsd <- assay(vst(dds))
vsd <- as.data.frame(vsd, drop=FALSE) # Convert to a data frame.
vsd$probe_id <- rownames(vsd) # Add probe ID as a column
vsd <- merge(as(vsd,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Adds a column of gene names for the associated probe ID
write.csv(vsd, file="../03_output/<date>_Vst_Transformed_Matrix_of_NormalizedCounts.csv") # Export as csv
```

## 5.2 Capture and export the loadings used for PCA:
```{r, results='hide'}
# Capture the loadings for PCA:
rv <- rowVars(assay(rld))
select <- order(rv, decreasing=TRUE)[seq_len(min(500, length(rv)))]
pca <- prcomp(t(assay(rld)[select,]))
loadings <- as.data.frame(pca$rotation)
loadings$probe_id <- rownames(loadings) # Add probe ID column
head(loadings)
head(genenames)
loadings <- merge(as(loadings,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Adds a column of gene names for the associated probe ID
write.csv(loadings, file="Date_PCA_loadings.csv") # Export to .csv
```

# 6. Citations
```{r}
sessionInfo()
citation()
```

