---
title: "RNAseq-Analysis"
author: "Eileen Owens"
date: "`r Sys.Date()`"
output:
  html_document:
  keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 300,
                      echo = TRUE,
                      cache = TRUE,
                      warning = FALSE,
                      keep_md = TRUE)
```
# Introduction
The purpose of this script is to perform a differential gene expression analysis on RNA-seq data with DESeq2. The DESeq2 documentation is available here: https://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html

```{r instructions, results='hide', include=FALSE}
# BEORE KNITTING THIS RMARKDOWN, make sure all code chunks have the options you desire in their header:
# eval=FALSE --> this code chunk will not be run
# include=FALSE --> code chunk will be run but not displayed in the final document
# echo=FALSE --> will run the code but will not display it in the code chunk above its results in the final document
# results='hide' --> code will be run and shown in the final document, but its results will not be displayed
# message=FALSE --> code will be run and shown in the final document, but no messages generated by the code will be displayed
```


# 1. Loading data and packages

## 1.1 Install necessary software packages (first time only):
```{r installation, results="hide", eval=FALSE}
if (!require("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
BiocManager::install(version = "3.18", force=TRUE)

options(BioC_mirror = "http://bioconductor.org")

BiocManager::install("DESeq2")
install.packages("corrplot")
install.packages("RColorBrewer")
install.packages("pheatmap")
BiocManager::install("apeglm")
install.packages("tidyverse")
install.packages("rlang")
BiocManager::install("EnhancedVolcano")
install.packages("ggplot2")
install.packages("stringr")
install.packages("ggpubr")
```

## 1.2 Load necessary software packages (every time):
```{r software-load, results="hide", message=FALSE}
library(DESeq2)
library(corrplot)
library(RColorBrewer)
library(pheatmap)
library(apeglm)
library(tidyverse)
library(rlang)
library(EnhancedVolcano)
library(ggplot2)
library(stringr)
library(ggpubr)
```

## 1.3 Read in the featureCounts data and metadata:
```{r data-input, results="hide"}
### Set the appropriate working directory ###
setwd("/Users/path/to/02_scripts") # copy the path to your 02_scripts directory and paste it here, in quotations. If you are a Windows user, you may have to swap the direction of your slashes from "\" to "/"

### Read in the FeatureCounts file ###
## By default, the column names in the featureCounts file are the full bam filename for your samples, which is cumbersome to work with. We will instead replace these column names with simplified sample IDs from a metadata file. ***IT IS VERY IMPORTANT THAT THE SAMPLES IN YOUR METADATA FILE ARE LISTED IN THE SAME ORDER AS THEY ARE IN THE COLUMNS OF YOUR FEATURECOUNTS FILE *** To check this, you can open your featureCounts file in Excel, or uncomment the line below to read it in to R with the headers intact first to check the order that sample bam files are listed:
# featureCountsPreview <- read.table(file = "../01_input/FeatureCountsFileName.txt", header = TRUE)

# Import the featureCounts file without its default header
countsData <- read.table(file = "../01_input/FeatureCountsFileName.txt", header = FALSE, row.names = 1, skip = 2) # row.names = 1 assigns the first column (geneid) as the row names for the data frame.

# Read in a metadata file in which the first column contains sample IDs and the subsequent columns contain information about those samples. ### *** THE ORDER IN WHICH SAMPLES ARE LISTED IN YOUR METADATA FILE MUST MATCH THE ORDER THEY ARE LISTED IN THE COLUMNS OF YOUR FEATURECOUNTS FILE *** ###
metadata <- read.table(file = "../01_input/metadata.txt", header = FALSE)
colnames(metadata) <- c("sample_name", "phenotype") # Adds column headers; ADJUST AS APPROPRIATE FOR YOUR METADATA FILE: e.g., c("sample_name", "phenotype", "sex", "breed", "etc")

# Give column names to countsData:
#### Because we are pasting sample IDs from our metadata file to the columns of our featureCounts file, it is important that the samples in your metadata file are listed in the SAME ORDER as they are in the columns of your featureCounts file. ####
as.vector(metadata$sample_name) # The last column names will be names for each sample. We can pull those names from metadata.
colnames(countsData) <- c("chr", "start", "stop", "strand", "length", as.vector(metadata$sample_name))
```

## 1.4 Make count matrix (cts) file for DESeq2

If using all samples, run the following chunk. Otherwise, skip this code chunk and include "echo=FALSE, eval=FALSE, include=FALSE" in the code chunk options prior to knitting.
```{r cts, results="hide"}
colnames(countsData) # Check the column numbers that contain your samples for indexing below.
head(countsData[,6:108]) # Adjust the indexing as needed to include only the sample columns with read counts. For example, [6:108] indexes on the 6th through 108th column.

# Save just the subset as an object called cts:
cts <- as.matrix(countsData[,6:108]) 
```

If using only only a subset of samples (e.g., only including certain phenotypes), adjust as necessary and run this code chunk. Otherwise, skip this code chunk and include "echo=FALSE, eval=FALSE, include=FALSE" in the code chunk options prior to knitting.
```{r cts_subset, results="hide", echo=FALSE, eval=FALSE, include=FALSE}
# To select for only certain phenotypes, include this code. Otherwise, comment out to include all samples.
colnames(countsData)
countsData_subset <- dplyr::select(countsData, -c("chr", "start", "stop", "strand", "length", "sample-to-exclude-1", "sample-to-exclude-2")) # Removes all columns except the count data for the desired samples.

# Save just the subset as an object called cts:
cts <- as.matrix(countsData_subset)
```

## 1.5 Make coldata file for DESeq2

If running all samples, use the following code chunk. Otherwise, skip this code chunk and include "echo=FALSE, eval=FALSE, include=FALSE" in the code chunk options prior to knitting.
```{r coldata}
# Reorganize the metadata table so the sample_name column values are now row names. If your metadata file includes more information than just a phenotype column (i.e., a column for sex, age, etc.), adjust this code as necessary.
rownames(metadata)<- metadata$sample_name
coldata <- metadata[, c("phenotype", "any other headers"), drop=FALSE] # drop=FALSE keeps row names
coldata$phenotype <- as.factor(coldata$phenotype)

# Ensure that the rownames of coldata exactly match the colnames of cts:
all(rownames(coldata) == colnames(cts)) # Should return TRUE
```

If using only a subset of samples, run the following code chunk. Otherwise, skip this code chunk and include "echo=FALSE, eval=FALSE, include=FALSE" in the code chunk options prior to knitting.
```{r coldata_subset, echo=FALSE, eval=FALSE, include=FALSE}
# Subset the metadata to only include the subset of interest.
remove_list <- c("sample-to-exclude-1", "sample-to-exclude-2") # Can paste the list used when making cts above
metadata_subset <- metadata %>%
  filter(! sample_name %in% remove_list)

# Reorganize the metadata table so the sample_name column values are now row headers.
rownames(metadata_subset)<- metadata_subset$sample_name
coldata <- metadata_subset[, c("phenotype"), drop=FALSE] # drop=FALSE keeps row names
coldata$phenotype <- as.factor(coldata$phenotype)

# Ensure that the rownames of coldata exactly match the colnames of cts:
all(rownames(coldata) == colnames(cts)) # Should return TRUE
```

# 2. Running a differential expression analysis with DESeq2

## 2.1 Set parameters for the study. 
See the DESeq2 manual (https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#quick-start) for examples and to ensure you're selecting the best design for your analysis. 
```{r dds, results="hide"}
dds <- DESeqDataSetFromMatrix(countData = cts,
                              colData = coldata,
                              design = ~ phenotype)
```

## 2.2 Filter for present genes
Excludes all samples that have less than 10 reads.
```{r filter-DESeq2-output-1, results="hide"}
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
```

## 2.3 Remove any samples to be excluded from the differential expression analysis (previously determined outliers, etc.) 
```{r filter-DESeq2-output-2, results='hide'}
# Comment this section out if no samples are to be excluded from the analysis.
#colnames(dds) # See which column contains the outlier.
#dds <- dds[,-X] # Replace X with column number that contains the outlier(s).
#colnames(dds)
```

## 2.4 Optional: Set factor levels
By default, R will choose a reference level for factors based on alphabetical order. Then, if you never tell the DESeq2 functions which level you want to compare against (e.g. which level represents the control group), the comparisons will be based on the alphabetical order of the levels. There are two solutions: you can either explicitly tell results which comparison to make using the contrast argument later, or you can explicitly set the factors levels. By default, this script does not set factor levels ahead of time, and instead uses the contrast argument later. If you choose to set factor levels, un-comment the code in this chunk and modify accordingly.
```{r factor-levels, results="hide"}
## There are 2 ways to set the factor level. Run one of the following below:
#dds$condition <- factor(dds$phenotype, levels = c("CTRL","Phenotype1","Phenotype2")) # Control group is listed first.
## OR
#dds$condition <- relevel(dds$phenotype, ref = "CTRL") # Relevel requires only specifying the reference level.
```

## 2.5A Perform DESeq2 analysis
```{r DESeq2, results="hide", message=FALSE}
dds <- DESeq(dds)
```

## 2.5B Save the dds object for ease of import in any downstream analyses.
```{r RDS, eval=FALSE}
saveRDS(dds, file="../03_output/DATE_PROJECTNAME_DDS.Rdata")
```

## 2.6 Plot dispersion estimates
A simple helper function that plots the per-gene dispersion estimates together with the fitted mean-dispersion relationship. This is a good way to double check your data is a good fit for the DESeq2 model. The data should generally scatter around the curve, with dispersion increasing with increasing mean expression levels. For more info and examples of what "good" and "bad" dispersion plots look like, see https://hbctraining.github.io/DGE_workshop_salmon_online/lessons/04b_DGE_DESeq2_analysis.html. 
```{r plot-dispersion, message=FALSE, fig.height=5, fig.width=8, fig.fullwidth=TRUE}
plotDispEsts(dds)
```

## 2.7 Perform a principal component analysis to identify any outliers before proceeding.
Perform a variance stabilized transformation of the normalized count data and perform the plotPCA function.
```{r PCA, results='hide'}
# Optional: Doing an rlog transformation of normalized count data instead of vst; takes longer with >50 samples.
#rld <- rlog(dds, blind=TRUE)
#rlog_pcaData <- plotPCA(rld, intgroup = "phenotype", returnData = TRUE)

vsd <- vst(dds, blind=TRUE)
vsd_pcaData <- plotPCA(vsd, intgroup="phenotype", returnData=TRUE)
```

### 2.7.1 Export the intgroup covariates used for PCA plotting:
```{r PCA-export}
# write.csv(rlog_pcaData, file="../03_output/<date>_PCA_data_rlog.csv")
write.csv(vsd_pcaData, file="../03_output/DATE_PCA_data_vst.csv")
```

### 2.7.3 Draw the PCA plot
```{r PCA-plot, message=FALSE, fig.height=8, fig.width=6, fig.fullwidth=TRUE}
#rlog_pcaData <- plotPCA(rld, intgroup = "phenotype", returnData = FALSE) +
 # geom_text(aes(label = colnames(rld)), position = position_nudge(y = -2)) # Uses the name column of rld as the dot label.
#rlog_pcaData

vsd_pcaData <- plotPCA(vsd, intgroup="phenotype", returnData=FALSE) +
  geom_text(aes(label=colnames(vsd)), position = position_nudge(y = -2))
vsd_pcaData
```
If principal component analysis reveals any outliers, go back up to section 2.4 and execute that code.


## 2.8 Differential expression analysis
Calculate the statistically significant differences between conditions. Specify the coefficient or contrast you want to build a results table for. Save each comparison to its own variable. Follow up with log fold change shrinkage for visualization and gene ranking.

```{r DEG-instructions, eval=FALSE, include=FALSE}
# The appropriate format is as follows: 
#BvsC <- results(dds, contrast=c("condition", "B", "C"))
#AvsB <- results(dds,contrast=c("condition", "A", "B"))
```

```{r res-file-generation, results='hide', message=FALSE}
res <- results(dds)

# If you set factor levels earlier, uncomment this section; otherwise, run a different "results" function for each comparison.
# resultsNames(dds) # lists the coefficients
#resLFC <- lfcShrink(dds, coef="phenotype_CD4_PTCL_vs_CD4_CTRL", type="apeglm")
#head(resLFC)

Group1vsGroup2_results <- results(dds, contrast=c("phenotype", "Group1", "Group2")) # Replace Group1 and Group2 with phenotypes from metadata.
Group1vsGroup2_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group1", "Group2"), res=Group1vsGroup2_results, type="normal")


Group1vsGroup3_results <- results(dds, contrast=c("phenotype", "Group1", "Group3")) # Replace Group1 and Group3 with phenotypes from metadata.
Group1vsGroup3_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group1", "Group3"), res=Group1vsGroup3_results, type="normal")


Group2vsGroup1_results <- results(dds, contrast=c("phenotype", "Group2", "Group1")) # Replace Group2 and Group1 with phenotypes from metadata.
Group2vsGroup1_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group2", "Group1"), res=Group2vsGroup1_results, type="normal")


Group2vsGroup3_results <- results(dds, contrast=c("phenotype", "Group2", "Group3")) # Replace Group2 and Group3 with phenotypes from metadata.
Group2vsGroup3_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group2", "Group3"), res=Group2vsGroup3_results, type="normal")


Group3vsGroup1_results <- results(dds, contrast=c("phenotype", "Group3", "Group1")) # Replace Group3 and Group1 with phenotypes from metadata.
Group3vsGroup1_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group3", "Group1"), res=Group3vsGroup1_results, type="normal")


Group3vsGroup2_results <- results(dds, contrast=c("phenotype", "Group3", "Group2")) # Replace Group3 and Group2 with phenotypes from metadata.
Group3vsGroup2_shrink <- lfcShrink(dds=dds, contrast=c("phenotype", "Group3", "Group2"), res=Group3vsGroup2_results, type="normal")
```

# 3. Exporting DESeq2 Data
## 3.1 Exporting results tables
Add a column with gene names, as the results tables in their current form only have the probe ID.
```{r DESeq2-data-export, results='hide'}
# Import a csv file where the first column is labeled "probe_id" and contains the probe IDs, and the second column is labeled "gene_name" and contains the preferred gene names.
genenames <- read.csv('../01_input/gene.description.csv')

# Add a column to the results table containing the probe IDs, which are currently the rownames.
Group1vsGroup2_shrink$probe_id <- rownames(Group1vsGroup2_shrink)

# Merge the genenames metadata file with the results tables by probe ID.
Group1vsGroup2_final_res <- merge(as(Group1vsGroup2_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE) # The all.x=TRUE argument says that it should include rows of CD4PTCLvsCD4CTRL_shrink even if there is no matching row of the genenames table.

# Convert probe ID back the rownames and remove the probe ID column.
rownames(Group1vsGroup2_final_res) <- Group1vsGroup2_final_res$probe_id
Group1vsGroup2_final_res <- Group1vsGroup2_final_res[,-1]

# Export the final result as a .csv file.
write.csv(Group1vsGroup2_final_res, file="../03_output/Group1vsGroup2_DESeq2res.csv")
```

Repeat for all comparisons.
```{r DESeq2-data-export-2, results='hide'}
Group1vsGroup3_shrink$probe_id <- rownames(Group1vsGroup3_shrink)
Group1vsGroup3_final_res <- merge(as(Group1vsGroup3_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group1vsGroup3_final_res) <- Group1vsGroup3_final_res$probe_id
Group1vsGroup3_final_res <- Group1vsGroup3_final_res[,-1]
write.csv(Group1vsGroup3_final_res, file="../03_output/Group1vsGroup3_DESeq2res.csv")

Group2vsGroup1_shrink$probe_id <- rownames(Group2vsGroup1_shrink)
Group2vsGroup1_final_res <- merge(as(Group2vsGroup1_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group2vsGroup1_final_res) <- Group2vsGroup1_final_res$probe_id
Group2vsGroup1_final_res <- Group2vsGroup1_final_res[,-1]
write.csv(Group2vsGroup1_final_res, file="../03_output/Group2vsGroup1_DESeq2res.csv")

Group2vsGroup3_shrink$probe_id <- rownames(Group2vsGroup3_shrink)
Group2vsGroup3_final_res <- merge(as(Group2vsGroup3_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group2vsGroup3_final_res) <- Group2vsGroup3_final_res$probe_id
Group2vsGroup3_final_res <- Group2vsGroup3_final_res[,-1]
write.csv(Group2vsGroup3_final_res, file="../03_output/Group2vsGroup3_DESeq2res.csv")

Group3vsGroup1_shrink$probe_id <- rownames(Group3vsGroup1_shrink)
Group3vsGroup1_final_res <- merge(as(Group3vsGroup1_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group3vsGroup1_final_res) <- Group3vsGroup1_final_res$probe_id
Group3vsGroup1_final_res <- Group3vsGroup1_final_res[,-1]
write.csv(Group3vsGroup1_final_res, file="../03_output/Group3vsGroup1_DESeq2res.csv")

Group3vsGroup2_shrink$probe_id <- rownames(Group3vsGroup2_shrink)
Group3vsGroup2_final_res <- merge(as(Group3vsGroup2_shrink,"data.frame"), genenames, by="probe_id", all.x=TRUE)
rownames(Group3vsGroup2_final_res) <- Group3vsGroup2_final_res$probe_id
Group3vsGroup2_final_res <- Group3vsGroup2_final_res[,-1]
write.csv(Group3vsGroup2_final_res, file="../03_output/Group3vsGroup2_DESeq2res.csv")
```

## 3.2 Exporting normalized count data
```{r export-normalized-counts, results='hide'}
sizeFactors(dds)
normalized_counts <- as.data.frame(counts(dds, normalized=TRUE))
normalized_counts$probe_id <- rownames(normalized_counts) # Add a column with probe ID.
normalized_counts <- merge(as(normalized_counts,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Add column with gene names.
write.csv(normalized_counts, file="../03_output/<date>_NormalizedCounts.csv")
```


# 4. Data Visualization

## 4.1 MA plots
Shows the log2 fold changes attributable to a given variable over the mean of normalized counts for all the samples in the DESeqDataSet.

```{r MAplot, fig.height=6, fig.width=10, fig.fullwidth=TRUE}
plotMA(Group1vsGroup2_shrink, main="Group1 vs Group2", ylim = c(-7,7), 
       ylab = "log fold change",
       xlab = "means of normalized counts")
```

## 4.2 Plot gene counts
Plot the normalized counts for genes of interest between sample phenotypes. (Also see: PlotGeneCounts.Rmd script)

### 4.2.1 Define genes of interest
Make the lists of genes to include in each plot.
```{r geneListForPlots}
# Define the lists of genes to plot. An example of 3 gene lists being used to make 3 plots is shown here.
geneList1 <- c("GENE1", "GENE2", "GENE3")
geneList2 <- c("GENE4", "GENE5", "GENE6")
geneList3 <- c("GENE7", "GENE8", "GENE9")

# Some gene sets to try related to T cell phenotypes and development are provided below.
## T cell phenotypes
# CD8genes <- c("EOMES", "IFNG", "TNF", "PRF1", "GZMB", "GZMA")
# Th1genes <- c("TBX21", "IFNG", "TNF")
# Th2genes <- c("GATA3", "IL4R", "IL5", "IL13")
# Th17genes <- c("RORC", "STAT3", "IL17A", "IL17B", "IL17D")
# Treggenes <- c("FOXP3", "IL10", "TGFB1")
# Tfhgenes <- c("BCL6", "IL21R", "CXCL13", "CXCR5")

## TCR signaling genes
# TCRgenes <- c("CD3E", "CD3D", "CD3G", "CD28", "ZAP70", "LCK", "FYN", "IL2RA", "IL2RB", "IL2RG")

## Markers of immaturity
# precursorGenes <- c("CD34", "KIT", "CCR9", "DNTT")
```

### 4.2.2 Prepare count data
Extract the normalized counts and variance stabilized transformed counts for the provided lists of genes.
```{r}

############ GENE LIST 1 ############
# Subset the normalized count matrix to include only the genes in this list
countsSubset1 <- normalized_counts %>%
  filter(gene_name %in% geneList1)

# Gather the columns to get the normalized counts for each sample in a single column. 
gathered_countsSubset1 <- countsSubset1 %>%
  gather(colnames(countsSubset1)[2:104], key = "sample_name", value="normalized_counts")  # ***Adjust the numbers in the brackets to index on just the sample columns containing counts.***
gathered_countsSubset1$normalized_counts <- as.numeric(as.character(gathered_countsSubset1$normalized_counts)) # Ensures the normalized count data are in the "numeric" class.

# Combine with metadata to allow coloring of counts by sample group. This will merge the 2 data frames with respect to the "sample_name" column (i.e., a column with the same column name in both data frames)
gathered_countsSubset1 <- inner_join(metadata, gathered_countsSubset1)


############ GENE LIST 2 ############
# Subset the normalized count matrix to include only the genes in this list
countsSubset2 <- normalized_counts %>%
  filter(gene_name %in% geneList2)

# Gather the columns to get the normalized counts for each sample in a single column. 
gathered_countsSubset2 <- countsSubset2 %>%
  gather(colnames(countsSubset2)[2:104], key = "sample_name", value="normalized_counts") # ***Adjust the numbers in the brackets to index on just the sample columns containing counts.***
gathered_countsSubset2$normalized_counts <- as.numeric(as.character(gathered_countsSubset2$normalized_counts)) # Ensures the normalized count data are in the "numeric" class.

# Combine with metadata to allow coloring of counts by sample group
gathered_countsSubset2 <- inner_join(metadata, gathered_countsSubset2)


############ GENE LIST 3 ############
# Subset the normalized count matrix to include only the genes in this list
countsSubset3 <- normalized_counts %>%
  filter(gene_name %in% geneList3)

# Gather the columns to get the normalized counts for each sample in a single column. 
gathered_countsSubset3 <- countsSubset3 %>%
  gather(colnames(countsSubset3)[2:104], key = "sample_name", value="normalized_counts") # ***Adjust the numbers in the brackets to index on just the sample columns containing counts.***
gathered_countsSubset3$normalized_counts <- as.numeric(as.character(gathered_countsSubset3$normalized_counts)) # Ensures the normalized count data are in the "numeric" class.

# Combine with metadata to allow coloring of counts by sample group
gathered_countsSubset3 <- inner_join(metadata, gathered_countsSubset3)
```

### 4.2.3 Check data distribution
Visually inspect the distribution of your count data. T-tests can be used for data that fits a normal Gaussian distribution, but a Wilcoxon test is preferred for comparing groups when the data is not normally distributed.

#### Density plots
```{r densityPlotsGeneLists}

############ GENE LIST 1 ############
ggdensity(gathered_countsSubset1$normalized_counts,
          main = "Count data density: GENELIST1",
          xlab = "Normalized counts")

############ GENE LIST 2 ############
ggdensity(gathered_countsSubset2$normalized_counts,
          main = "Count data density: GENELIST2",
          xlab = "Normalized counts")

############ GENE LIST 3 ############
ggdensity(gathered_countsSubset3$normalized_counts,
          main = "Count data density: GENELIST3",
          xlab = "Normalized counts")
```

#### Q-Q plots
```{r QQplotsGeneLists}

############ GENE LIST 1 ############
ggqqplot(gathered_countsSubset1$normalized_counts, main = "Q-Q plot for normal distribution of count data: GENELIST1")

############ GENE LIST 2 ############
ggqqplot(gathered_countsSubset2$normalized_counts, main = "Q-Q plot for normal distribution of count data: GENELIST2")

############ GENE LIST 3 ############
ggqqplot(gathered_countsSubset3$normalized_counts, main = "Q-Q plot for normal distribution of count data: GENELIST3")
```

### 4.2.4 Draw the plots
#### Dotplots
```{r dotplotGeneListNormCounts, fig.width=8, fig.height=5}

############ GENE LIST 1 ############
ggplot(gathered_countsSubset1, aes(x=gene_name, y=normalized_counts, color=phenotype, shape=phenotype)) +
  #geom_boxplot(position=position_dodge(0.3)) + # Un-comment this line to overlay box plots
  geom_jitter(size=2, position=position_dodge(0.3)) +
  scale_color_manual(values = c("Phenotype1" = "blue", "Phenotype2" = "red", "Phenotype3" = "green3")) + # replace "Phenotype1" etc. with appropriate phenotypes from your metadata file
  scale_y_log10() +
  
  # set axis labels and plot title
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Gene Expression") +
  
  # display stats; replace wilcox_test with t_test based on results of normalization test
  geom_pwc(aes(group=phenotype), method = "wilcox_test", dodge=0.6, tip.length=0, hide.ns = TRUE, label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  coord_cartesian(clip = "off") +
  theme(axis.text.x = element_text(size=14, face="bold", angle=45, hjust=1),
        plot.title = element_text(hjust=0.5),
        legend.text = element_text(size=12),
        legend.title = element_text(size=14))


############ GENE LIST 2 ############
ggplot(gathered_countsSubset2, aes(x=gene_name, y=normalized_counts, color=phenotype, shape=phenotype)) +
  #geom_boxplot(position=position_dodge(0.3)) + # Un-comment this line to overlay box plots
  geom_jitter(size=2, position=position_dodge(0.3)) +
  scale_color_manual(values = c("Phenotype1" = "blue", "Phenotype2" = "red", "Phenotype3" = "green3")) + # replace "Phenotype1" etc. with appropriate phenotypes from your metadata file
  scale_y_log10() +
  
  # set axis labels and plot title
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Gene Expression") +
  
  # display stats; replace wilcox_test with t_test based on results of normalization test
  geom_pwc(aes(group=phenotype), method = "wilcox_test", dodge=0.6, tip.length=0, hide.ns = TRUE, label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  coord_cartesian(clip = "off") +
  theme(axis.text.x = element_text(size=14, face="bold", angle=45, hjust=1),
        plot.title = element_text(hjust=0.5),
        legend.text = element_text(size=12),
        legend.title = element_text(size=14))


############ GENE LIST 3 ############
ggplot(gathered_countsSubset3, aes(x=gene_name, y=normalized_counts, color=phenotype, shape=phenotype)) +
  #geom_boxplot(position=position_dodge(0.3)) + # Un-comment this line to overlay box plots
  geom_jitter(size=2, position=position_dodge(0.3)) +
  scale_color_manual(values = c("Phenotype1" = "blue", "Phenotype2" = "red", "Phenotype3" = "green3")) + # replace "Phenotype1" etc. with appropriate phenotypes from your metadata file
  scale_y_log10() +
  
  # set axis labels and plot title
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Gene Expression") +
  
  # display stats; replace wilcox_test with t_test based on results of normalization test
  geom_pwc(aes(group=phenotype), method = "wilcox_test", dodge=0.6, tip.length=0, hide.ns = TRUE, label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  coord_cartesian(clip = "off") +
  theme(axis.text.x = element_text(size=14, face="bold", angle=45, hjust=1),
        plot.title = element_text(hjust=0.5),
        legend.text = element_text(size=12),
        legend.title = element_text(size=14))
```

#### Faceted dotplots
```{r facetedDotPlotNormCounts, fig.width=10, fig.height=9}

############ GENE LIST 1 ############
ggplot(gathered_countsSubset1, aes(x=phenotype, y=normalized_counts, color=phenotype, shape=phenotype)) +
  geom_jitter(size=2, position=position_dodge(0.3)) +
  scale_y_log10() +
  facet_wrap(~gene_name, scales="free") + # free axis scales (as opposed to fixed) are preferred as count data may vary between the individual plots
  scale_x_discrete(limits=c("Phenotype1", "Phenotype2", "Phenotype3")) + # change the order of items along the X axis
  
  # set axis labels and plot title
  labs(x="Group",
       y="log10 Normalized Counts",
       fill="Group",
       title="Gene Expression") +
  
  # display stats
  stat_compare_means(comparisons = list(c("Phenotype1", "Phenotype2"), c("Phenotype2", "Phenotype3"), c("Phenotype1", "Phenotype3")), 
                     tip.length=0, size=3, method = "wilcox.test", label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  theme(plot.title= element_text(hjust = 0.5))


############ GENE LIST 2 ############
ggplot(gathered_countsSubset2, aes(x=phenotype, y=normalized_counts, color=phenotype, shape=phenotype)) +
  geom_jitter(size=2, position=position_dodge(0.3)) +
  scale_y_log10() +
  facet_wrap(~gene_name, scales="free") + # free axis scales (as opposed to fixed) are preferred as count data may vary between the individual plots
  scale_x_discrete(limits=c("Phenotype1", "Phenotype2", "Phenotype3")) + # change the order of items along the X axis
  
  # set axis labels and plot title
  labs(x="Group",
       y="log10 Normalized Counts",
       fill="Group",
       title="Gene Expression") +
  
  # display stats
  stat_compare_means(comparisons = list(c("Phenotype1", "Phenotype2"), c("Phenotype2", "Phenotype3"), c("Phenotype1", "Phenotype3")), 
                     tip.length=0, size=3, method = "wilcox.test", label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  theme(plot.title= element_text(hjust = 0.5))


############ GENE LIST 3 ############
ggplot(gathered_countsSubset3, aes(x=phenotype, y=normalized_counts, color=phenotype, shape=phenotype)) +
  geom_jitter(size=2, position=position_dodge(0.3)) +
  scale_y_log10() +
  facet_wrap(~gene_name, scales="free") + # free axis scales (as opposed to fixed) are preferred as count data may vary between the individual plots
  scale_x_discrete(limits=c("Phenotype1", "Phenotype2", "Phenotype3")) + # change the order of items along the X axis
  
  # set axis labels and plot title
  labs(x="Group",
       y="log10 Normalized Counts",
       fill="Group",
       title="Gene Expression") +
  
  # display stats
  stat_compare_means(comparisons = list(c("Phenotype1", "Phenotype2"), c("Phenotype2", "Phenotype3"), c("Phenotype1", "Phenotype3")), 
                     tip.length=0, size=3, method = "wilcox.test", label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  theme(plot.title= element_text(hjust = 0.5))
```

#### Box plots
```{r facetedBoxPlotGeneListNormCounts, fig.width=10, fig.height=8}
############ GENE LIST 1 ############
ggplot(gathered_countsSubset1, aes(phenotype, normalized_counts, fill=phenotype)) +
  geom_boxplot() +
  scale_y_log10() +
  facet_wrap(~gene_name, scales="free") + # free axis scales (as opposed to fixed) are preferred as count data may vary between the individual plots
  scale_x_discrete(limits=c("Phenotype1", "Phenotype2", "Phenotype3")) + # change the order of items along the X axis
  
  # set axis labels and plot title
  labs(x="Group",
       y="log10 Normalized Counts",
       fill="Group",
       title="Gene Expression") +
  
  # display stats
  stat_compare_means(comparisons = list(c("Phenotype1", "Phenotype2"), c("Phenotype2", "Phenotype3"), c("Phenotype1", "Phenotype3")),
                     tip.length=0, size=3, method = "wilcox.test", label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))


############ GENE LIST 2 ############
ggplot(gathered_countsSubset2, aes(phenotype, normalized_counts, fill=phenotype)) +
  geom_boxplot() +
  scale_y_log10() +
  facet_wrap(~gene_name, scales="free") + # free axis scales (as opposed to fixed) are preferred as count data may vary between the individual plots
  scale_x_discrete(limits=c("Phenotype1", "Phenotype2", "Phenotype3")) + # change the order of items along the X axis
  
  # set axis labels and plot title
  labs(x="Group",
       y="log10 Normalized Counts",
       fill="Group",
       title="Gene Expression") +
  
  # display stats
  stat_compare_means(comparisons = list(c("Phenotype1", "Phenotype2"), c("Phenotype2", "Phenotype3"), c("Phenotype1", "Phenotype3")),
                     tip.length=0, size=3, method = "wilcox.test", label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))


############ GENE LIST 3 ############
ggplot(gathered_countsSubset3, aes(phenotype, normalized_counts, fill=phenotype)) +
  geom_boxplot() +
  scale_y_log10() +
  facet_wrap(~gene_name, scales="free") + # free axis scales (as opposed to fixed) are preferred as count data may vary between the individual plots
  scale_x_discrete(limits=c("Phenotype1", "Phenotype2", "Phenotype3")) + # change the order of items along the X axis
  
  # set axis labels and plot title
  labs(x="Group",
       y="log10 Normalized Counts",
       fill="Group",
       title="Gene Expression") +
  
  # display stats
  stat_compare_means(comparisons = list(c("Phenotype1", "Phenotype2"), c("Phenotype2", "Phenotype3"), c("Phenotype1", "Phenotype3")),
                     tip.length=0, size=3, method = "wilcox.test", label = "p.signif") +
  
  # set style preferences
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
```


## 4.3 Optional: Plot counts for a subset of samples only.
Run the following code with the desired samples to exclude, then go back to 4.2.2 and replace "normalized_counts" with "normalized_counts_subset". Be sure to adjust your indexing to reflect the columns (samples) that have been excluded.
```{r plot-counts-subset, message=FALSE, eval=FALSE}
sampleSubset <- c("probe_id", "Sample1", "Sample2", "Sample3", "gene_name")
normalized_counts_subset <- normalized_counts[, sampleSubset]
```


## 4.4 Correlation Matrices
Evaluate the sample-to-sample correlation by calculating the distances (dissimilarities) between each sample and creating a matrix of distance values. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (>0.80). Samples with low correlation may indicate outliers or sample contamination.
```{r corr-matrix-setup, message=FALSE}
rld <- rlog(dds, blind=TRUE)
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix(sampleDists) #convert from data.frame -> matrix
rownames(sampleDistMatrix) <- paste(rld$phenotype, colnames(rld), sep="-") # Add sample labels
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255) #Pick colors
```

Use this matrix to draw a heatmap that groups samples based on their gene expression similarity. The color blocks indicate substructure in the data, so you should expect to see your replicates cluster together as a block for each sample group.
```{r corr-matrix, message=FALSE}
p <- pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

## 4.5 Volcano Plots
Volcano plots are a nice way of displaying the fold change against the p-value.
### Volcano plot with top differentially expressed genes labeled
```{r EnhancedVolcano, message=FALSE, fig.height=4, fig.width=8.5, fig.fullwidth=TRUE}

volcano_data1 <- Group1vsGroup2_final_res

EnhancedVolcano(volcano_data1, 
                lab = volcano_data1$gene_name,
                x = 'log2FoldChange',
                y = 'padj',
                title = 'Group1 vs. Group2',
                FCcutoff = 1.5,
                pCutoff = 0.05,
                pointSize = 2.0,
                labSize = 4.0,
                labCol = 'black',
                labFace = 'bold',
                colAlpha = 4/5,
                legendPosition = 'right',
                legendLabSize = 12,
                legendIconSize = 6.0,
                drawConnectors = TRUE,
                widthConnectors = 0.2,
                colConnectors = 'black'
                )

# Repeat for as many comparisons as desired
volcano_data2 <- Group2vsGroup1_final_res

EnhancedVolcano(volcano_data2, 
                lab = volcano_data2$gene_name,
                x = 'log2FoldChange',
                y = 'padj',
                title = 'Group1 vs. Group2',
                FCcutoff = 1.5,
                pCutoff = 0.05,
                pointSize = 2.0,
                labSize = 4.0,
                labCol = 'black',
                labFace = 'bold',
                colAlpha = 4/5,
                legendPosition = 'right',
                legendLabSize = 12,
                legendIconSize = 6.0,
                drawConnectors = TRUE,
                widthConnectors = 0.2,
                colConnectors = 'black'
                )
```

### Volcano plot with only key genes labeled
```{r EnhancedVolcano-selectGenes, message=FALSE, fig.height=4.5, fig.width=6, fig.fullwidth=TRUE}

EnhancedVolcano(volcano_data1, 
                lab = volcano_data1$gene_name,
                x = 'log2FoldChange',
                y = 'padj',
                selectLab = c('GATA3', 'PTEN', 'IFNG', 'EOMES', 'TBX21', 'KIT', 'DNTT', 'CD34', 'IL2RA', 'IL2RB', 'DLA-DRA', 'DLA-DQA1', 'HLA-DQB1', 'HLA-DQB2'), # Replace these gene names with your genes of interest.
                title = 'Group1 vs. Group2',
                FCcutoff = 1.5,
                pCutoff = 0.05,
                pointSize = 2.0,
                labSize = 4.0,
                labCol = 'black',
                labFace = 'bold',
                colAlpha = 4/5,
                legendPosition = 'right',
                legendLabSize = 12,
                legendIconSize = 6.0,
                drawConnectors = TRUE,
                widthConnectors = 0.2,
                colConnectors = 'black'
                )
```

# 5. Final data export

## 5.1 Export the matrices of rlog and vst transformed normalized counts:
```{r}
# Perform r-stabilized log transformation of the count data and export.
rld_matrix <- assay(rlog(dds, blind=FALSE))
rld_matrix <- as.data.frame(rld_matrix, drop=FALSE) # Convert to a data frame.
rld_matrix$probe_id <- rownames(rld_matrix) # Add probe ID as a column
rld_matrix <- merge(as(rld_matrix,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Adds a column of gene names for the associated probe ID
write.csv(rld_matrix, file="../03_output/<date>_Rlog_Transformed_Matrix_of_NormalizedCounts.csv") # Export as csv

# Perform variance stabilized transformation of the count data and export.
vsd <- assay(vst(dds))
vsd <- as.data.frame(vsd, drop=FALSE) # Convert to a data frame.
vsd$probe_id <- rownames(vsd) # Add probe ID as a column
vsd <- merge(as(vsd,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Adds a column of gene names for the associated probe ID
write.csv(vsd, file="../03_output/<date>_Vst_Transformed_Matrix_of_NormalizedCounts.csv") # Export as csv
```

## 5.2 Capture and export the loadings used for PCA:
```{r, results='hide'}
# Capture the loadings for PCA:
rv <- rowVars(assay(rld))
select <- order(rv, decreasing=TRUE)[seq_len(min(500, length(rv)))]
pca <- prcomp(t(assay(rld)[select,]))
loadings <- as.data.frame(pca$rotation)
loadings$probe_id <- rownames(loadings) # Add probe ID column
head(loadings)
head(genenames)
loadings <- merge(as(loadings,"data.frame"), genenames, by="probe_id", all.x=TRUE) # Adds a column of gene names for the associated probe ID
write.csv(loadings, file="Date_PCA_loadings.csv") # Export to .csv
```

# 6. Citations
```{r}
sessionInfo()
citation()
```

